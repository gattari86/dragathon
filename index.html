<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Futuristic Metallic Animation Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <style>
      /* Styles are identical to the previous version - condensed for brevity */
      @font-face { font-family: 'LucideIcons'; src: url(https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.ttf) format('truetype'); }
      .lucide { font-family: 'LucideIcons'; font-size: 1.25rem; line-height: 1; vertical-align: middle; }
      #canvas-container { width: 100%; height: 60vh; max-height: 500px; position: relative; overflow: hidden; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); }
      canvas { display: block; width: 100%; height: 100%; }
      #recording-indicator { position: absolute; top: 1rem; right: 1rem; width: 1rem; height: 1rem; background-color: red; border-radius: 50%; display: none; animation: pulse 1.5s infinite; z-index: 10; }
      @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
      .btn { @apply inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 transition-colors duration-150 ease-in-out; }
      .btn-primary { @apply text-white bg-indigo-600 hover:bg-indigo-700 focus:ring-indigo-500; }
      .btn-secondary { @apply text-indigo-700 bg-indigo-100 hover:bg-indigo-200 focus:ring-indigo-500; }
      .btn-danger { @apply text-white bg-red-600 hover:bg-red-700 focus:ring-red-500; }
      .btn-disabled { @apply bg-gray-300 text-gray-500 cursor-not-allowed hover:bg-gray-300; }
      #message-box { position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 0.75rem 1.5rem; border-radius: 0.5rem; z-index: 1000; display: none; font-family: 'Inter', sans-serif; font-size: 0.875rem; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
      .hidden { display: none; }
      .input-base { @apply mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm bg-white disabled:bg-gray-100 disabled:cursor-not-allowed; }
      .color-input { @apply p-1 h-10 w-full block bg-white border border-gray-300 rounded-md shadow-sm cursor-pointer focus:outline-none focus:ring-indigo-500 focus:border-indigo-500; }
      #loading-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 20; display: flex; justify-content: center; align-items: center; color: white; font-size: 1.2rem; border-radius: 0.5rem; text-align: center; }
      .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid #fff; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 1rem; }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 font-['Inter'] text-gray-800 p-4 md:p-8">

    <div class="max-w-5xl mx-auto bg-white p-6 rounded-lg shadow-lg">
        <h1 class="text-2xl md:text-3xl font-bold mb-6 text-center text-indigo-700">Futuristic Metallic Animation Generator</h1>

        <div id="canvas-container" class="mb-6 bg-black">
            <div id="loading-overlay">
                <div class="flex flex-col items-center">
                     <div class="spinner"></div>
                     <span id="loading-text">Loading Assets...</span>
                 </div>
            </div>
            <div id="recording-indicator" title="Recording..."></div>
            </div>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-6">
             <div class="space-y-2"> <label for="color-palette">...</label> <select id="color-palette">...</select> <div id="custom-colors">...</div> </div>
            <div class="space-y-2"> <label for="movement-pattern">...</label> <select id="movement-pattern">...</select> </div>
            <div class="space-y-2"> <label for="shape-type">...</label> <select id="shape-type">...</select> <div id="text-options">...</div> <div class="mt-4"> <label for="shape-count">...</label> <input type="range" id="shape-count">...</div> </div>
            <div class="space-y-2"> <label for="background-type">...</label> <select id="background-type">...</select> <div id="solid-color-option">...</div> <div id="gradient-color-options">...</div> </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mt-6 pt-6 border-t border-gray-200">
             <div class="flex items-center gap-2"> <label for="video-format">...</label> <select id="video-format">...</select> </div>
             <button id="start-record-btn">...</button> <button id="stop-record-btn">...</button> <a id="download-link">...</a>
        </div>
         <div class="mt-6 text-sm text-gray-600 bg-indigo-50 p-4 rounded-md border border-indigo-200">
             <h3 class="font-semibold">...</h3> <ol>...</ol>
        </div>
    </div>

    <div id="message-box"></div>

    <script id="vertexShader" type="shader/vertex">varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }</script>
    <script id="fragmentShader" type="shader/fragment">varying vec2 vUv; uniform vec3 color1; uniform vec3 color2; uniform float direction; void main() { vec2 uv = vUv; float mixValue; if (direction == 0.0) { mixValue = uv.y; } else if (direction == 1.0) { mixValue = uv.x; } else if (direction == 2.0) { mixValue = (uv.x + uv.y) / 2.0; } else if (direction == 3.0) { mixValue = 1.0 - uv.y; } else if (direction == 4.0) { mixValue = (uv.x + (1.0 - uv.y)) / 2.0; } else { mixValue = uv.y; } gl_FragColor = vec4(mix(color1, color2, mixValue), 1.0); }</script>

    <script>
        // --- Global Variables ---
        // Identical to previous version
        let scene, camera, renderer, shapes = [];
        let backgroundPlane, backgroundMaterial;
        let animationId;
        let mediaRecorder; let recordedChunks = [];
        let currentPalette = []; let usePaletteGradient = false;
        let currentMovement = 'vortex';
        let currentShapeType = 'cube';
        let currentShapeCount = 30;
        let currentText = 'Futuristic';
        let loadedFont = null;
        let environmentMap = null;
        const clock = new THREE.Clock();
        const defaultBgColor = 0x0a0a0a;

        // --- DOM Elements ---
        // Identical to previous version
        const canvasContainer = document.getElementById('canvas-container');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const colorPaletteSelect = document.getElementById('color-palette');
        const customColorsDiv = document.getElementById('custom-colors');
        const customColorInputs = [ document.getElementById('custom-color-1'), document.getElementById('custom-color-2'), document.getElementById('custom-color-3'), document.getElementById('custom-color-4'), document.getElementById('custom-color-5') ];
        const usePaletteGradientCheckbox = document.getElementById('use-palette-gradient');
        const movementPatternSelect = document.getElementById('movement-pattern');
        const shapeTypeSelect = document.getElementById('shape-type');
        const textOptionsDiv = document.getElementById('text-options');
        const textInput = document.getElementById('text-input');
        const shapeCountSlider = document.getElementById('shape-count');
        const shapeCountLabel = document.getElementById('shape-count-label');
        const backgroundTypeSelect = document.getElementById('background-type');
        const solidColorOptionDiv = document.getElementById('solid-color-option');
        const backgroundColorSolidInput = document.getElementById('background-color-solid');
        const gradientColorOptionsDiv = document.getElementById('gradient-color-options');
        const backgroundColorGradient1Input = document.getElementById('background-color-gradient-1');
        const backgroundColorGradient2Input = document.getElementById('background-color-gradient-2');
        const gradientDirectionSelect = document.getElementById('gradient-direction');
        const videoFormatSelect = document.getElementById('video-format');
        const mp4Option = document.getElementById('mp4-option');
        const startRecordBtn = document.getElementById('start-record-btn');
        const stopRecordBtn = document.getElementById('stop-record-btn');
        const downloadLink = document.getElementById('download-link');
        const recordingIndicator = document.getElementById('recording-indicator');
        const messageBox = document.getElementById('message-box');

        // --- Palettes ---
        // Identical to previous version
        const palettes = { metallic_cool: [0xc0c0c0, 0x808080, 0xadd8e6, 0x4682b4, 0x778899], metallic_warm: [0xb8860b, 0xffd700, 0xcd7f32, 0x8b4513, 0xdda0dd], rainbow: [0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x0000ff, 0x4b0082, 0x9400d3], vaporwave: [0xff71ce, 0x01cdfe, 0x05ffa1, 0xb967ff, 0xfff79a], monochrome: [0x000000, 0x444444, 0x888888, 0xcccccc, 0xffffff], custom: [] };

        // --- Asset Loading (Using Promises) ---
        // Identical to previous version
        function loadAssets() {
             const fontLoader = new THREE.FontLoader(); const cubeTextureLoader = new THREE.CubeTextureLoader();
             const fontURL = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json';
             const envMapBaseURL = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/textures/cube/pisa/';
             const envMapURLs = [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ].map(f => envMapBaseURL + f);
             loadingText.textContent = "Loading Font..."; const fontPromise = new Promise((resolve, reject) => { fontLoader.load(fontURL, resolve, undefined, reject); });
             loadingText.textContent = "Loading Environment Map..."; const envMapPromise = new Promise((resolve, reject) => { cubeTextureLoader.load(envMapURLs, resolve, undefined, reject); });
             Promise.allSettled([fontPromise, envMapPromise]).then((results) => { let loadedEnvMapTexture = null; if (results[0].status === 'fulfilled') { loadedFont = results[0].value; console.log("Font loaded."); } else { console.error('Font loading failed:', results[0].reason); showMessage('Error: Failed to load font. Text features disabled.', true); } if (results[1].status === 'fulfilled') { loadedEnvMapTexture = results[1].value; loadedEnvMapTexture.encoding = THREE.sRGBEncoding; console.log("Env map loaded."); } else { console.error('Env map loading failed:', results[1].reason); showMessage('Warning: Failed env map load. Generating fallback...', false); } initThreeJS(loadedFont, loadedEnvMapTexture); loadingOverlay.style.display = 'none'; });
        }

        // --- Initialization (Receives loaded assets) ---
        function initThreeJS(font, loadedEnvMap) {
            loadedFont = font;
            environmentMap = loadedEnvMap;

            scene = new THREE.Scene();
            const aspectRatio = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setClearColor(defaultBgColor, 1.0);
            renderer.outputEncoding = THREE.sRGBEncoding;
            // --- COLOR FIX: Changed tone mapping ---
            renderer.toneMapping = THREE.LinearToneMapping; // Less aggressive than ACESFilmic
            renderer.toneMappingExposure = 1.0; // Keep exposure standard for now
            canvasContainer.appendChild(renderer.domElement);

            // Generate Fallback Env Map if loading failed
            if (!environmentMap) {
                console.log("Generating fallback environment map...");
                 try {
                    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256, { format: THREE.RGBFormat, generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter, encoding: THREE.sRGBEncoding } );
                    const cubeCamera = new THREE.CubeCamera( 1, 1000, cubeRenderTarget );
                    const originalBackground = scene.background; updateBackground(); // Apply current background
                    cubeCamera.update( renderer, scene );
                    scene.background = originalBackground; // Restore
                    environmentMap = cubeRenderTarget.texture;
                    console.log("Fallback env map generated."); showMessage('Using generated fallback env map.', false);
                 } catch (error) {
                     console.error("Error generating fallback env map:", error); showMessage('Error generating fallback env map. Metallic effect disabled.', true); environmentMap = null;
                 }
            }
            scene.environment = environmentMap; // Apply final map

            // Lighting (Unchanged)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); directionalLight.position.set(8, 15, 10); scene.add(directionalLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.6, 200); pointLight.position.set(-10, -5, 20); scene.add(pointLight);

            createBackgroundPlane(); // Unchanged

            // Initial setup (Unchanged)
            currentShapeType = shapeTypeSelect.value; textOptionsDiv.classList.toggle('hidden', !(currentShapeType === 'text' || currentShapeType === 'mixed_all')); currentText = textInput.value; currentShapeCount = parseInt(shapeCountSlider.value, 10);
            updatePalette(); updateBackground(); createShapes(); checkMp4Support(); startAnimation();
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- Background Plane Creation (Unchanged) ---
        function createBackgroundPlane() { /* ... */
             const planeGeometry = new THREE.PlaneGeometry(2, 2); const uniforms = { color1: { value: new THREE.Color(0x1e3a8a) }, color2: { value: new THREE.Color(0xf472b6) }, direction: { value: 0.0 } }; backgroundMaterial = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: document.getElementById('vertexShader').textContent, fragmentShader: document.getElementById('fragmentShader').textContent, depthWrite: false, depthTest: false }); backgroundPlane = new THREE.Mesh(planeGeometry, backgroundMaterial); backgroundPlane.position.z = -500; backgroundPlane.visible = false; scene.add(backgroundPlane);
        }

        // --- Shape & Text Creation (UPDATED Material) ---
        function createShapes() {
            if (!renderer || !scene) return;
            shapes.forEach(shape => scene.remove(shape)); shapes = [];
            const includesText = currentShapeType === 'text' || currentShapeType === 'mixed_all';
            const includesGeometry = currentShapeType !== 'text';
            if (includesText && !loadedFont) { showMessage("Font not loaded, cannot create text.", true); return; }

            for (let i = 0; i < currentShapeCount; i++) {
                let geometry; let isTextShape = false;
                if (currentShapeType === 'text') { isTextShape = true; } else if (currentShapeType === 'mixed_all') { isTextShape = Math.random() < 0.3; } else { isTextShape = false; }
                if (isTextShape) { if (!currentText || currentText.trim() === "" || !loadedFont) continue; try { geometry = new THREE.TextGeometry(currentText, { font: loadedFont, size: 3, height: 0.5, curveSegments: 4, bevelEnabled: false }); geometry.center(); } catch (error) { console.error("Error creating TextGeometry:", error); continue; } } else if (includesGeometry) { const gt = (currentShapeType === 'mixed_geo' || currentShapeType === 'mixed_all') ? 'mixed' : currentShapeType; geometry = getGeometry(gt); } else { continue; }
                if (!geometry) continue;

                // --- COLOR FIX: Adjusted material ---
                const material = new THREE.MeshStandardMaterial({
                    color: getRandomPaletteColor(i / currentShapeCount),
                    metalness: 0.75, // Reduced metalness
                    roughness: 0.3, // Slightly increased roughness
                    envMap: environmentMap,
                    transparent: true, opacity: 0.9
                });

                const shape = new THREE.Mesh(geometry, material);
                const initialScale = isTextShape ? 1.5 : Math.random() * 2 + 1;
                shape.scale.setScalar(initialScale);
                shape.position.set((Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100);
                shape.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);
                shapes.push(shape); scene.add(shape);
            }
        }

        // --- Geometry Helper (Unchanged) ---
        function getGeometry(type) { /* ... */
             if (type === 'mixed_geo' || type === 'mixed') { const gt=['cube','sphere','torus','icosahedron']; return getGeometry(gt[Math.floor(Math.random()*gt.length)]); } if (!getGeometry.cache) getGeometry.cache = {}; if (getGeometry.cache[type]) return getGeometry.cache[type]; let g; switch(type){ case 'sphere': g=new THREE.SphereGeometry(1.2,32,16); break; case 'torus': g=new THREE.TorusKnotGeometry(1,0.3,100,16); break; case 'icosahedron': g=new THREE.IcosahedronGeometry(1.5); break; case 'cube': default: g=new THREE.BoxGeometry(1.8,1.8,1.8); break; } getGeometry.cache[type]=g; return g;
        }

        // --- Palette Management (Unchanged) ---
        function updatePalette() { /* ... */
             const sp=colorPaletteSelect.value; usePaletteGradient=usePaletteGradientCheckbox.checked&&sp==='custom'; if(sp==='custom'){ customColorsDiv.classList.remove('hidden'); currentPalette=customColorInputs.map(i=>new THREE.Color(i.value)).filter(Boolean); if(currentPalette.length<2){showMessage("Custom palette needs >= 2 colors.",true); currentPalette=palettes.metallic_cool.map(h=>new THREE.Color(h)); usePaletteGradient=false;} }else{ customColorsDiv.classList.add('hidden'); currentPalette=palettes[sp].map(h=>new THREE.Color(h)); usePaletteGradient=false; } shapes.forEach((s,i)=>{if(s.material)s.material.color.copy(getRandomPaletteColor(i/shapes.length));});
        }

        // --- Get Random Palette Color (Unchanged) ---
        function getRandomPaletteColor(t = Math.random()) { /* ... */
             if(currentPalette.length===0)return new THREE.Color(0xc0c0c0); if(usePaletteGradient&&currentPalette.length>=2){ const seg=1/(currentPalette.length-1); const idx=Math.min(Math.floor(t/seg),currentPalette.length-2); const lt=(t%seg)/seg; return new THREE.Color().lerpColors(currentPalette[idx],currentPalette[idx+1],lt); }else{ return currentPalette[Math.floor(Math.random()*currentPalette.length)]; }
        }

        // --- Background Management (Unchanged) ---
        function updateBackground() { /* ... */
             if(!scene||!renderer)return; const t=backgroundTypeSelect.value; solidColorOptionDiv.classList.toggle('hidden',t!=='solid'); gradientColorOptionsDiv.classList.toggle('hidden',t!=='gradient'); if(t==='gradient'){ const c1=backgroundColorGradient1Input.value; const c2=backgroundColorGradient2Input.value; const dir=parseFloat(gradientDirectionSelect.value); if(backgroundMaterial?.uniforms){ backgroundMaterial.uniforms.color1.value.set(c1); backgroundMaterial.uniforms.color2.value.set(c2); backgroundMaterial.uniforms.direction.value=dir; } if(backgroundPlane)backgroundPlane.visible=true; scene.background=null; renderer.setClearColor(0x000000,0); }else{ if(backgroundPlane)backgroundPlane.visible=false; const bgC=(t==='solid')?backgroundColorSolidInput.value:defaultBgColor; const colO=new THREE.Color(bgC); scene.background=colO; renderer.setClearColor(colO,1.0); }
        }

        // --- Animation Loop (UPDATED HSL) ---
        function animate() {
             if (!renderer || !scene || !camera) return;
             animationId = requestAnimationFrame(animate);
             const delta = clock.getDelta(); const time = clock.getElapsedTime();
             applyMovementPattern(time, delta);

             // Update shape colors
             shapes.forEach((shape, index) => {
                 if (usePaletteGradient) {
                     const gradientT = (Math.sin(time * 0.5 + index * 0.1) + 1) / 2;
                     if (shape.material) shape.material.color.copy(getRandomPaletteColor(gradientT));
                 } else if (currentMovement === 'vortex' || currentMovement === 'grid' || currentMovement === 'wave') {
                      let hue;
                      if (currentMovement === 'vortex') hue = (time * 0.1 + index * 0.01) % 1;
                      if (currentMovement === 'grid') hue = (Math.sin((time + index * 0.1) * 0.3 * 2) + 1) / 2;
                      if (currentMovement === 'wave') { const ws = 0.8, wa = 15; hue = (shape.position.y / wa * 0.5 + 0.5 + time * 0.05) % 1; }

                      // --- COLOR FIX: Adjusted HSL ---
                      if (hue !== undefined && shape.material?.color?.setHSL) {
                           shape.material.color.setHSL(hue, 1.0, 0.65); // Increased lightness slightly, kept saturation high
                      }
                 } else if (currentMovement === 'chaos' && Math.random() < 0.01) {
                      if (shape.material) shape.material.color.copy(getRandomPaletteColor());
                 }
             });
             renderer.render(scene, camera);
        }

        // --- Start Animation (Unchanged) ---
        function startAnimation() { if (animationId) cancelAnimationFrame(animationId); animate(); }

        // --- Movement Patterns (Unchanged) ---
        function applyMovementPattern(time, delta) { /* ... */
            const speed=0.5, scaleSpeed=0.3, rotationSpeed=0.4; shapes.forEach((shape, index)=>{ const offsetTime=time+index*0.1; switch(currentMovement){ case 'vortex': shape.position.x=Math.sin(offsetTime*speed)*(25+index*0.1); shape.position.y=Math.cos(offsetTime*speed)*(25+index*0.1); shape.position.z=Math.sin(offsetTime*speed*0.5)*35-35; shape.rotation.x+=delta*rotationSpeed; shape.rotation.y+=delta*rotationSpeed*1.2; break; case 'grid': const gs=Math.ceil(Math.sqrt(currentShapeCount)), sp=12; const gx=(index%gs-gs/2+0.5)*sp; const gy=(Math.floor(index/gs)-gs/2+0.5)*sp; shape.position.set(gx,gy,Math.sin(offsetTime*0.5)*18); const scale=1+Math.sin(offsetTime*scaleSpeed*2)*0.5; shape.scale.set(scale,scale,scale); shape.rotation.z+=delta*rotationSpeed*0.5; break; case 'chaos': shape.position.x+=(Math.random()-0.5)*delta*25; shape.position.y+=(Math.random()-0.5)*delta*25; shape.position.z+=(Math.random()-0.5)*delta*25; shape.position.clampScalar(-70,70); shape.rotation.x+=delta*rotationSpeed*(Math.random()-0.5)*2; shape.rotation.y+=delta*rotationSpeed*(Math.random()-0.5)*2; shape.scale.setScalar(1+Math.sin(offsetTime*scaleSpeed)*0.3); break; case 'tunnel': shape.position.z+=delta*35*(1+index*0.01); shape.rotation.z+=delta*rotationSpeed*2; shape.rotation.x+=delta*rotationSpeed*0.5; const radius=18+Math.sin(offsetTime*0.2)*6; const angle=offsetTime*0.3+index*Math.PI*0.1; shape.position.x=Math.cos(angle)*radius; shape.position.y=Math.sin(angle)*radius; if(shape.position.z>camera.position.z){ shape.position.z=-180-Math.random()*60; if(!usePaletteGradient&&shape.material)shape.material.color.copy(getRandomPaletteColor(index/shapes.length)); } break; case 'wave': const ws=0.8, wa=18, wf=0.1; shape.position.x=(index%15-7.5)*6; shape.position.y=Math.sin(shape.position.x*wf+time*ws)*wa; shape.position.z=Math.cos(time*ws*0.7+index*0.1)*25-10; shape.rotation.y+=delta*rotationSpeed; shape.scale.setScalar(1+Math.cos(time*ws+index*0.2)*0.4); break; } });
        }

        // --- Event Handlers (Unchanged) ---
        function onWindowResize() { /* ... */ if(!renderer||!camera||!canvasContainer)return; const w=canvasContainer.clientWidth; const h=canvasContainer.clientHeight; if(w===0||h===0)return; camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); }
        colorPaletteSelect.addEventListener('change', updatePalette); usePaletteGradientCheckbox.addEventListener('change', updatePalette); customColorInputs.forEach(i=>i.addEventListener('input',()=>{if(colorPaletteSelect.value==='custom')updatePalette();})); movementPatternSelect.addEventListener('change',(e)=>{currentMovement=e.target.value;updatePalette();}); shapeTypeSelect.addEventListener('change',(e)=>{currentShapeType=e.target.value; textOptionsDiv.classList.toggle('hidden',!(currentShapeType==='text'||currentShapeType==='mixed_all')); createShapes();}); textInput.addEventListener('change',(e)=>{currentText=e.target.value; if(currentShapeType==='text'||currentShapeType==='mixed_all'){createShapes();}}); shapeCountSlider.addEventListener('input',(e)=>{currentShapeCount=parseInt(e.target.value,10); shapeCountLabel.textContent=`${currentShapeCount} objects`;}); shapeCountSlider.addEventListener('change',createShapes); backgroundTypeSelect.addEventListener('change',updateBackground); backgroundColorSolidInput.addEventListener('input',updateBackground); backgroundColorGradient1Input.addEventListener('input',updateBackground); backgroundColorGradient2Input.addEventListener('input',updateBackground); gradientDirectionSelect.addEventListener('change',updateBackground);

        // --- MP4 Support Check (Unchanged) ---
        function checkMp4Support() { /* ... */ const m='video/mp4'; const o=document.getElementById('mp4-option'); if(MediaRecorder?.isTypeSupported?.(m)){o.disabled=false;}else{o.disabled=true; if(videoFormatSelect.value===m){videoFormatSelect.value='video/webm; codecs=vp9';} showMessage('Note: MP4 recording may not be supported. WebM recommended.');} }

        // --- Recording Logic (ADDED Guard Clause & Logging) ---
        function startRecording() {
            console.log("Attempting to start recording..."); // Logging
            // --- RECORDING FIX: Added guard clause ---
            if (!renderer || !renderer.domElement) {
                 showMessage('Error: Renderer not ready for recording. Please wait a moment and try again.', true);
                 console.error("startRecording failed: Renderer or renderer.domElement not found.");
                 return;
            }
            if (!window.MediaRecorder) { showMessage('Error: MediaRecorder API not supported.', true); return; }

            const canvas = renderer.domElement;
            if (canvas.width === 0 || canvas.height === 0) { showMessage('Error: Canvas size is zero. Cannot record.', true); return; }

            const selectedFormat = videoFormatSelect.value;
            const options = { mimeType: selectedFormat };
            const fileExtension = selectedFormat.includes('mp4') ? 'mp4' : 'webm';
            console.log(`Selected format: ${selectedFormat}`); // Logging

            if (!MediaRecorder.isTypeSupported(selectedFormat)) {
                 const fallbackFormat = 'video/webm; codecs=vp8';
                 showMessage(`Warning: ${selectedFormat} not supported. Trying ${fallbackFormat}.`, true);
                 options.mimeType = fallbackFormat;
                 if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                     showMessage(`Error: ${options.mimeType} also not supported. Cannot record.`, true);
                     console.error("No suitable recording format found.");
                     return;
                 }
            }

            try {
                 console.log("Creating MediaRecorder with options:", options); // Logging
                 mediaRecorder = new MediaRecorder(canvas.captureStream(30), options);
            } catch (e) {
                 showMessage(`Error creating MediaRecorder: ${e.message}. Try WebM.`, true);
                 console.error("MediaRecorder creation failed:", e);
                 return;
            }

            recordedChunks = [];
            mediaRecorder.ondataavailable = (event) => { if (event.data.size > 0) recordedChunks.push(event.data); };
            mediaRecorder.onstop = () => {
                 console.log("Recording stopped. Chunks length:", recordedChunks.length); // Logging
                 const blob = new Blob(recordedChunks, { type: options.mimeType });
                 const url = URL.createObjectURL(blob);
                 downloadLink.href = url;
                 const now = new Date(); const ts = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}`;
                 downloadLink.download = `futuristic_animation_${currentMovement}_${currentShapeType}_${ts}.${fileExtension}`;
                 downloadLink.classList.remove('hidden'); downloadLink.classList.add('inline-flex');
                 startRecordBtn.disabled = false; stopRecordBtn.disabled = true; startRecordBtn.classList.remove('btn-disabled'); stopRecordBtn.classList.add('btn-disabled'); videoFormatSelect.disabled = false; recordingIndicator.style.display = 'none';
                 showMessage('Recording stopped. Click Download Video.');
            };
             mediaRecorder.onerror = (event) => {
                 showMessage(`Recording error: ${event.error.message}. Try WebM.`, true); console.error("MediaRecorder error:", event.error); stopRecording(); // Ensure UI cleanup on error
             };

            mediaRecorder.start();
            console.log("MediaRecorder started."); // Logging
            startRecordBtn.disabled = true; stopRecordBtn.disabled = false; startRecordBtn.classList.add('btn-disabled'); stopRecordBtn.classList.remove('btn-disabled'); videoFormatSelect.disabled = true; downloadLink.classList.add('hidden'); recordingIndicator.style.display = 'block';
            showMessage(`Recording started (${options.mimeType})...`);
        }

        // --- Stop Recording (Unchanged) ---
        function stopRecording() { /* ... */
            console.log("Stop recording called."); if(mediaRecorder?.state!=='inactive'){ try { mediaRecorder.stop(); mediaRecorder.stream.getTracks().forEach(t=>t.stop()); } catch(e){ console.error("Error stopping recorder:", e); } } startRecordBtn.disabled=false; stopRecordBtn.disabled=true; startRecordBtn.classList.remove('btn-disabled'); stopRecordBtn.classList.add('btn-disabled'); videoFormatSelect.disabled=false; recordingIndicator.style.display='none';
         }

         // --- Utility Functions ---
         function showMessage(message, isError = false) { /* ... */
             messageBox.textContent=message; messageBox.style.backgroundColor=isError?'rgba(220,38,38,0.8)':'rgba(0,0,0,0.8)'; messageBox.style.display='block'; setTimeout(()=>{messageBox.style.display='none';}, isError?6000:4000);
         }

        // --- Run ---
         window.onload = () => {
             loadAssets(); // Start loading assets
         };

    </script>
</body>
</html>

    </script>
</body>
</html>

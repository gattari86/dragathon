<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Futuristic Metallic Animation Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <style>
      @font-face {
        font-family: 'LucideIcons';
        src: url(https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.ttf) format('truetype');
      }
      .lucide { font-family: 'LucideIcons'; font-size: 1.25rem; line-height: 1; vertical-align: middle; }
      #canvas-container { width: 100%; height: 60vh; max-height: 500px; position: relative; overflow: hidden; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); }
      canvas { display: block; width: 100%; height: 100%; }
      #recording-indicator { position: absolute; top: 1rem; right: 1rem; width: 1rem; height: 1rem; background-color: red; border-radius: 50%; display: none; animation: pulse 1.5s infinite; z-index: 10; }
      @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
      .btn { @apply inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 transition-colors duration-150 ease-in-out; }
      .btn-primary { @apply text-white bg-indigo-600 hover:bg-indigo-700 focus:ring-indigo-500; }
      .btn-secondary { @apply text-indigo-700 bg-indigo-100 hover:bg-indigo-200 focus:ring-indigo-500; }
      .btn-danger { @apply text-white bg-red-600 hover:bg-red-700 focus:ring-red-500; }
      .btn-disabled { @apply bg-gray-300 text-gray-500 cursor-not-allowed hover:bg-gray-300; }
      #message-box { position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 0.75rem 1.5rem; border-radius: 0.5rem; z-index: 1000; display: none; font-family: 'Inter', sans-serif; font-size: 0.875rem; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
      .hidden { display: none; }
      .input-base { @apply mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm bg-white disabled:bg-gray-100 disabled:cursor-not-allowed; }
      .color-input { @apply p-1 h-10 w-full block bg-white border border-gray-300 rounded-md shadow-sm cursor-pointer focus:outline-none focus:ring-indigo-500 focus:border-indigo-500; }
      #loading-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 20; display: flex; justify-content: center; align-items: center; color: white; font-size: 1.2rem; border-radius: 0.5rem; text-align: center; }
      .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid #fff; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 1rem; }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 font-['Inter'] text-gray-800 p-4 md:p-8">

    <div class="max-w-5xl mx-auto bg-white p-6 rounded-lg shadow-lg">
        <h1 class="text-2xl md:text-3xl font-bold mb-6 text-center text-indigo-700">Futuristic Metallic Animation Generator</h1>

        <div id="canvas-container" class="mb-6 bg-black">
            <div id="loading-overlay">
                <div class="flex flex-col items-center">
                     <div class="spinner"></div>
                     <span id="loading-text">Loading Assets...</span>
                 </div>
            </div>
            <div id="recording-indicator" title="Recording..."></div>
            </div>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-6">
            <div class="space-y-2">
                <label for="color-palette" class="block text-sm font-medium text-gray-700">Color Palette:</label>
                <select id="color-palette" name="color-palette" class="input-base">
                    <option value="metallic_cool">Metallic Cool</option>
                    <option value="metallic_warm">Metallic Warm</option>
                    <option value="rainbow">Rainbow</option>
                    <option value="vaporwave">Vaporwave</option>
                    <option value="monochrome">Monochrome</option>
                    <option value="custom">Custom</option>
                </select>
                <div id="custom-colors" class="hidden space-y-2 mt-2">
                     <label class="block text-sm font-medium text-gray-700">Custom Colors (2-5):</label>
                     <input type="color" id="custom-color-1" value="#c0c0c0" class="color-input">
                     <input type="color" id="custom-color-2" value="#44aadd" class="color-input">
                     <input type="color" id="custom-color-3" value="#ffffff" class="color-input">
                     <input type="color" id="custom-color-4" value="#888888" class="color-input">
                     <input type="color" id="custom-color-5" value="#333333" class="color-input">
                     <div class="flex items-center mt-2">
                         <input id="use-palette-gradient" type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                         <label for="use-palette-gradient" class="ml-2 block text-sm text-gray-900">Use as Gradient</label>
                     </div>
                </div>
            </div>

            <div class="space-y-2">
                <label for="movement-pattern" class="block text-sm font-medium text-gray-700">Movement Pattern:</label>
                <select id="movement-pattern" name="movement-pattern" class="input-base">
                    <option value="vortex">Spinning Vortex</option>
                    <option value="grid">Pulsating Grid</option>
                    <option value="chaos">Morphing Chaos</option>
                    <option value="tunnel">Infinite Tunnel</option>
                    <option value="wave">Geometric Wave</option>
                </select>
            </div>

             <div class="space-y-2">
                <label for="shape-type" class="block text-sm font-medium text-gray-700">Object Type:</label>
                <select id="shape-type" name="shape-type" class="input-base">
                    <option value="cube">Cubes</option>
                    <option value="sphere">Spheres</option>
                    <option value="torus">Torus Knots</option>
                    <option value="icosahedron">Icosahedrons</option>
                    <option value="mixed_geo">Mixed Geometry</option>
                    <option value="text">Text Only</option>
                    <option value="mixed_all">Mixed Geometry & Text</option>
                </select>
                 <div id="text-options" class="space-y-2 mt-2 hidden"> <label for="text-input" class="block text-sm font-medium text-gray-700">Text to Add:</label>
                     <input type="text" id="text-input" name="text-input" value="Futuristic" class="input-base" placeholder="Enter text here...">
                 </div>
                 <div class="mt-4 space-y-2">
                    <label for="shape-count" class="block text-sm font-medium text-gray-700">Object Count:</label>
                    <input type="range" id="shape-count" name="shape-count" min="5" max="100" value="30" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                    <span id="shape-count-label" class="text-sm text-gray-500">30 objects</span>
                </div>
            </div>

             <div class="space-y-2">
                 <label for="background-type" class="block text-sm font-medium text-gray-700">Background:</label>
                 <select id="background-type" name="background-type" class="input-base">
                     <option value="default">Default (Dark)</option>
                     <option value="solid">Solid Color</option>
                     <option value="gradient">Linear Gradient</option>
                 </select>
                 <div id="solid-color-option" class="hidden mt-2">
                     <label for="background-color-solid" class="block text-sm font-medium text-gray-700">Background Color:</label>
                     <input type="color" id="background-color-solid" value="#0a0a0a" class="color-input">
                 </div>
                 <div id="gradient-color-options" class="hidden space-y-2 mt-2">
                     <label class="block text-sm font-medium text-gray-700">Gradient Colors:</label>
                     <input type="color" id="background-color-gradient-1" value="#000020" class="color-input">
                     <input type="color" id="background-color-gradient-2" value="#404080" class="color-input">
                     <label for="gradient-direction" class="block text-sm font-medium text-gray-700">Direction:</label>
                     <select id="gradient-direction" name="gradient-direction" class="input-base">
                         <option value="0">Top to Bottom</option>
                         <option value="1">Left to Right</option>
                         <option value="2">Top-Left to Bottom-Right</option>
                         <option value="3">Bottom to Top</option>
                         <option value="4">Bottom-Left to Top-Right</option>
                     </select>
                 </div>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mt-6 pt-6 border-t border-gray-200">
             <div class="flex items-center gap-2 w-full sm:w-auto">
                 <label for="video-format" class="text-sm font-medium text-gray-700 whitespace-nowrap">Format:</label>
                 <select id="video-format" name="video-format" class="input-base py-1.5">
                     <option value="video/webm; codecs=vp9">WebM (VP9)</option>
                     <option value="video/webm; codecs=vp8">WebM (VP8)</option>
                     <option id="mp4-option" value="video/mp4">MP4 (H.264)</option>
                 </select>
             </div>
             <button id="start-record-btn" class="btn btn-primary w-full sm:w-auto">
                 <span class="lucide mr-2">&#9210;</span> Start Recording
             </button>
             <button id="stop-record-btn" class="btn btn-danger w-full sm:w-auto" disabled>
                 <span class="lucide mr-2">&#9724;</span> Stop Recording
             </button>
             <a id="download-link" class="btn btn-secondary w-full sm:w-auto hidden">
                 <span class="lucide mr-2">&#11123;</span> Download Video
             </a>
        </div>
         <div class="mt-6 text-sm text-gray-600 bg-indigo-50 p-4 rounded-md border border-indigo-200">
            <h3 class="font-semibold text-indigo-800 mb-2">How to Use:</h3>
            <ol class="list-decimal list-inside space-y-1">
                <li>Wait for assets to load (font/textures).</li>
                <li>Adjust colors, movement, object type (including text), count, and background.</li>
                <li>Enter desired text if using 'Text Only' or 'Mixed Geometry & Text'.</li>
                <li>Select video recording format (MP4 may not be supported by your browser).</li>
                <li>Click "Start Recording", then "Stop Recording".</li>
                <li>Click "Download Video" to save.</li>
                <li>Note: Using text can impact performance. Lower the object count if needed. If env map fails, a fallback is generated.</li>
            </ol>
        </div>
    </div>

    <div id="message-box"></div>

    <script id="vertexShader" type="shader/vertex">varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }</script>
    <script id="fragmentShader" type="shader/fragment">varying vec2 vUv; uniform vec3 color1; uniform vec3 color2; uniform float direction; void main() { vec2 uv = vUv; float mixValue; if (direction == 0.0) { mixValue = uv.y; } else if (direction == 1.0) { mixValue = uv.x; } else if (direction == 2.0) { mixValue = (uv.x + uv.y) / 2.0; } else if (direction == 3.0) { mixValue = 1.0 - uv.y; } else if (direction == 4.0) { mixValue = (uv.x + (1.0 - uv.y)) / 2.0; } else { mixValue = uv.y; } gl_FragColor = vec4(mix(color1, color2, mixValue), 1.0); }</script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer, shapes = [];
        let backgroundPlane, backgroundMaterial;
        let animationId;
        let mediaRecorder; let recordedChunks = [];
        let currentPalette = []; let usePaletteGradient = false;
        let currentMovement = 'vortex';
        let currentShapeType = 'cube';
        let currentShapeCount = 30;
        let currentText = 'Futuristic';
        let loadedFont = null;
        let environmentMap = null; // Can be loaded texture or generated fallback
        const clock = new THREE.Clock();
        const defaultBgColor = 0x0a0a0a;

        // --- DOM Elements ---
        const canvasContainer = document.getElementById('canvas-container');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const colorPaletteSelect = document.getElementById('color-palette');
        const customColorsDiv = document.getElementById('custom-colors');
        const customColorInputs = [ /* ... */
             document.getElementById('custom-color-1'), document.getElementById('custom-color-2'),
             document.getElementById('custom-color-3'), document.getElementById('custom-color-4'),
             document.getElementById('custom-color-5'),
        ];
        const usePaletteGradientCheckbox = document.getElementById('use-palette-gradient');
        const movementPatternSelect = document.getElementById('movement-pattern');
        const shapeTypeSelect = document.getElementById('shape-type');
        const textOptionsDiv = document.getElementById('text-options');
        const textInput = document.getElementById('text-input');
        const shapeCountSlider = document.getElementById('shape-count');
        const shapeCountLabel = document.getElementById('shape-count-label');
        const backgroundTypeSelect = document.getElementById('background-type');
        const solidColorOptionDiv = document.getElementById('solid-color-option');
        const backgroundColorSolidInput = document.getElementById('background-color-solid');
        const gradientColorOptionsDiv = document.getElementById('gradient-color-options');
        const backgroundColorGradient1Input = document.getElementById('background-color-gradient-1');
        const backgroundColorGradient2Input = document.getElementById('background-color-gradient-2');
        const gradientDirectionSelect = document.getElementById('gradient-direction');
        const videoFormatSelect = document.getElementById('video-format');
        const mp4Option = document.getElementById('mp4-option');
        const startRecordBtn = document.getElementById('start-record-btn');
        const stopRecordBtn = document.getElementById('stop-record-btn');
        const downloadLink = document.getElementById('download-link');
        const recordingIndicator = document.getElementById('recording-indicator');
        const messageBox = document.getElementById('message-box');

        // --- Palettes ---
        const palettes = { /* ... same as before ... */
            metallic_cool: [0xc0c0c0, 0x808080, 0xadd8e6, 0x4682b4, 0x778899], metallic_warm: [0xb8860b, 0xffd700, 0xcd7f32, 0x8b4513, 0xdda0dd], rainbow: [0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x0000ff, 0x4b0082, 0x9400d3], vaporwave: [0xff71ce, 0x01cdfe, 0x05ffa1, 0xb967ff, 0xfff79a], monochrome: [0x000000, 0x444444, 0x888888, 0xcccccc, 0xffffff], custom: []
        };

        // --- Asset Loading (Using Promises) ---
        function loadAssets() {
            const fontLoader = new THREE.FontLoader();
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            const fontURL = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json';
            const envMapBaseURL = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/textures/cube/pisa/';
            const envMapURLs = [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ].map(f => envMapBaseURL + f);

            loadingText.textContent = "Loading Font...";
            const fontPromise = new Promise((resolve, reject) => {
                fontLoader.load(fontURL, resolve, undefined, reject);
            });

             loadingText.textContent = "Loading Environment Map...";
            const envMapPromise = new Promise((resolve, reject) => {
                cubeTextureLoader.load(envMapURLs, resolve, undefined, reject);
            });

            // Wait for both promises to settle (either succeed or fail)
            Promise.allSettled([fontPromise, envMapPromise])
                .then((results) => {
                    let loadedEnvMapTexture = null;

                    // Process font result
                    if (results[0].status === 'fulfilled') {
                        loadedFont = results[0].value;
                        console.log("Font loaded.");
                    } else {
                        console.error('Font loading failed:', results[0].reason);
                        showMessage('Error: Failed to load font. Text features disabled.', true);
                        // Allow proceeding without font
                    }

                    // Process environment map result
                    if (results[1].status === 'fulfilled') {
                        loadedEnvMapTexture = results[1].value;
                        loadedEnvMapTexture.encoding = THREE.sRGBEncoding;
                        console.log("Environment map loaded from CDN.");
                    } else {
                        console.error('CubeTexture loading failed:', results[1].reason);
                        showMessage('Warning: Failed to load environment map from CDN. Generating fallback...', false); // Not an error, just info
                        // Will generate fallback in initThreeJS if loadedEnvMapTexture remains null
                    }

                    // Now initialize the scene, passing the results
                    initThreeJS(loadedFont, loadedEnvMapTexture);
                    loadingOverlay.style.display = 'none'; // Hide loading overlay
                });
        }


        // --- Initialization (Receives loaded assets) ---
        function initThreeJS(font, loadedEnvMap) {
            loadedFont = font; // Store globally even if null
            environmentMap = loadedEnvMap; // Store globally, might be null

            // Scene setup
            scene = new THREE.Scene();

            // Camera setup
            const aspectRatio = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera.position.z = 50;

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setClearColor(defaultBgColor, 1.0);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            canvasContainer.appendChild(renderer.domElement);

            // --- Generate Fallback Env Map if loading failed ---
            if (!environmentMap) {
                console.log("Generating fallback environment map...");
                 try {
                    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256, { // Lower resolution for fallback
                        format: THREE.RGBFormat,
                        generateMipmaps: true,
                        minFilter: THREE.LinearMipmapLinearFilter,
                        encoding: THREE.sRGBEncoding // Match output encoding
                    } );
                    const cubeCamera = new THREE.CubeCamera( 1, 1000, cubeRenderTarget );

                    // Render a simple scene for the fallback map (e.g., just the background)
                    // Temporarily set background for the render
                    const originalBackground = scene.background;
                    updateBackground(); // Apply current background settings to scene
                    cubeCamera.update( renderer, scene );
                    scene.background = originalBackground; // Restore original (might be null)

                    environmentMap = cubeRenderTarget.texture; // Use the generated texture
                    console.log("Fallback environment map generated.");
                    showMessage('Using generated fallback environment map.', false);
                 } catch (error) {
                     console.error("Error generating fallback env map:", error);
                     showMessage('Error generating fallback environment map. Metallic effect disabled.', true);
                     environmentMap = null; // Ensure it's null if generation also fails
                 }
            }
             // --- End Fallback Generation ---

            // Apply the final environment map (loaded or generated) to the scene
            scene.environment = environmentMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); directionalLight.position.set(8, 15, 10); scene.add(directionalLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.6, 200); pointLight.position.set(-10, -5, 20); scene.add(pointLight);

            // Create Gradient Background Plane
            createBackgroundPlane();

            // Initial setup based on UI defaults
            currentShapeType = shapeTypeSelect.value;
            textOptionsDiv.classList.toggle('hidden', !(currentShapeType === 'text' || currentShapeType === 'mixed_all')); // Initial visibility
            currentText = textInput.value;
            currentShapeCount = parseInt(shapeCountSlider.value, 10);
            updatePalette();
            updateBackground(); // Call *after* scene/renderer exist
            createShapes();
            checkMp4Support();
            startAnimation();

            window.addEventListener('resize', onWindowResize, false);
        }

        // --- Background Plane Creation (Unchanged) ---
        function createBackgroundPlane() { /* ... same as before ... */
             const planeGeometry = new THREE.PlaneGeometry(2, 2);
             const uniforms = { color1: { value: new THREE.Color(0x1e3a8a) }, color2: { value: new THREE.Color(0xf472b6) }, direction: { value: 0.0 } };
             backgroundMaterial = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: document.getElementById('vertexShader').textContent, fragmentShader: document.getElementById('fragmentShader').textContent, depthWrite: false, depthTest: false });
             backgroundPlane = new THREE.Mesh(planeGeometry, backgroundMaterial);
             backgroundPlane.position.z = -500; backgroundPlane.visible = false;
             scene.add(backgroundPlane);
        }

        // --- Shape & Text Creation (UPDATED - check font) ---
        function createShapes() {
            // Added guard: Don't run if renderer doesn't exist yet
            if (!renderer || !scene) return;

            shapes.forEach(shape => scene.remove(shape));
            shapes = [];

            const includesText = currentShapeType === 'text' || currentShapeType === 'mixed_all';
            const includesGeometry = currentShapeType !== 'text';

            // Check if font is needed and available *again*
            if (includesText && !loadedFont) {
                showMessage("Font not loaded, cannot create text shapes.", true);
                // Optionally disable text-related shape types here if font failed
                // shapeTypeSelect.value = 'cube'; // Force back to geometry
                // currentShapeType = 'cube';
                // textOptionsDiv.classList.add('hidden');
                return; // Stop creation if font needed but missing
            }

            for (let i = 0; i < currentShapeCount; i++) {
                let geometry;
                let isTextShape = false;

                if (currentShapeType === 'text') { isTextShape = true; }
                else if (currentShapeType === 'mixed_all') { isTextShape = Math.random() < 0.3; }
                else { isTextShape = false; }

                if (isTextShape) {
                    if (!currentText || currentText.trim() === "") continue;
                    // Ensure loadedFont is valid before creating TextGeometry
                    if (!loadedFont) continue;
                    try {
                        geometry = new THREE.TextGeometry(currentText, { font: loadedFont, size: 3, height: 0.5, curveSegments: 4, bevelEnabled: false });
                        geometry.center();
                    } catch (error) {
                        console.error("Error creating TextGeometry:", error);
                        continue; // Skip this shape if text creation fails
                    }
                } else if (includesGeometry) {
                    const geoType = (currentShapeType === 'mixed_geo' || currentShapeType === 'mixed_all') ? 'mixed' : currentShapeType;
                    geometry = getGeometry(geoType);
                } else { continue; }

                if (!geometry) continue;

                const material = new THREE.MeshStandardMaterial({
                    color: getRandomPaletteColor(i / currentShapeCount),
                    metalness: 0.9, roughness: 0.25,
                    envMap: environmentMap, // Use the final map (loaded or generated)
                    transparent: true, opacity: 0.9
                });

                const shape = new THREE.Mesh(geometry, material);
                const initialScale = isTextShape ? 1.5 : Math.random() * 2 + 1;
                shape.scale.setScalar(initialScale);
                shape.position.set((Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100);
                shape.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);
                shapes.push(shape);
                scene.add(shape);
            }
        }

        // --- Geometry Helper (Unchanged) ---
        function getGeometry(type) { /* ... same as before ... */
            if (type === 'mixed_geo' || type === 'mixed') { const gt=['cube','sphere','torus','icosahedron']; return getGeometry(gt[Math.floor(Math.random()*gt.length)]); }
            if (!getGeometry.cache) getGeometry.cache = {}; if (getGeometry.cache[type]) return getGeometry.cache[type]; let g; switch(type){ case 'sphere': g=new THREE.SphereGeometry(1.2,32,16); break; case 'torus': g=new THREE.TorusKnotGeometry(1,0.3,100,16); break; case 'icosahedron': g=new THREE.IcosahedronGeometry(1.5); break; case 'cube': default: g=new THREE.BoxGeometry(1.8,1.8,1.8); break; } getGeometry.cache[type]=g; return g;
         }

        // --- Palette Management (Unchanged) ---
        function updatePalette() { /* ... same as before ... */
            const selectedPalette = colorPaletteSelect.value; usePaletteGradient = usePaletteGradientCheckbox.checked && selectedPalette === 'custom'; if(selectedPalette === 'custom'){ customColorsDiv.classList.remove('hidden'); currentPalette = customColorInputs.map(i=>new THREE.Color(i.value)).filter(Boolean); if(currentPalette.length<2){ showMessage("Custom palette needs >= 2 colors.", true); currentPalette = palettes.metallic_cool.map(h=>new THREE.Color(h)); usePaletteGradient=false; } }else{ customColorsDiv.classList.add('hidden'); currentPalette = palettes[selectedPalette].map(h=>new THREE.Color(h)); usePaletteGradient=false; } shapes.forEach((s,i)=>{ if(s.material)s.material.color.copy(getRandomPaletteColor(i/shapes.length)); });
        }

        // --- Get Random Palette Color (Unchanged) ---
        function getRandomPaletteColor(t = Math.random()) { /* ... same as before ... */
            if(currentPalette.length===0)return new THREE.Color(0xc0c0c0); if(usePaletteGradient&&currentPalette.length>=2){ const seg=1/(currentPalette.length-1); const idx=Math.min(Math.floor(t/seg),currentPalette.length-2); const lt=(t%seg)/seg; return new THREE.Color().lerpColors(currentPalette[idx],currentPalette[idx+1],lt); }else{ return currentPalette[Math.floor(Math.random()*currentPalette.length)]; }
        }

        // --- Background Management (Unchanged) ---
        function updateBackground() { /* ... same as before ... */
            if (!scene || !renderer) return; // Guard against calls before init
            const type = backgroundTypeSelect.value; solidColorOptionDiv.classList.toggle('hidden', type !== 'solid'); gradientColorOptionsDiv.classList.toggle('hidden', type !== 'gradient'); if(type === 'gradient'){ const c1=backgroundColorGradient1Input.value; const c2=backgroundColorGradient2Input.value; const dir=parseFloat(gradientDirectionSelect.value); if(backgroundMaterial?.uniforms){ backgroundMaterial.uniforms.color1.value.set(c1); backgroundMaterial.uniforms.color2.value.set(c2); backgroundMaterial.uniforms.direction.value = dir; } if(backgroundPlane) backgroundPlane.visible = true; scene.background = null; renderer.setClearColor(0x000000, 0); } else { if(backgroundPlane) backgroundPlane.visible = false; const bgC = (type === 'solid') ? backgroundColorSolidInput.value : defaultBgColor; const colO = new THREE.Color(bgC); scene.background = colO; renderer.setClearColor(colO, 1.0); }
        }

        // --- Animation Loop (Unchanged) ---
        function animate() { /* ... same as before ... */
             if (!renderer || !scene || !camera) return; animationId = requestAnimationFrame(animate); const delta = clock.getDelta(); const time = clock.getElapsedTime(); applyMovementPattern(time, delta); shapes.forEach((shape, index) => { if (usePaletteGradient) { const gt=(Math.sin(time*0.5+index*0.1)+1)/2; shape.material.color.copy(getRandomPaletteColor(gt)); } else if (currentMovement==='vortex'||currentMovement==='grid'||currentMovement==='wave') { let hue; if(currentMovement==='vortex')hue=(time*0.1+index*0.01)%1; if(currentMovement==='grid')hue=(Math.sin((time+index*0.1)*0.3*2)+1)/2; if(currentMovement==='wave'){const ws=0.8,wa=15;hue=(shape.position.y/wa*0.5+0.5+time*0.05)%1;} if(hue!==undefined&&shape.material?.color?.setHSL){shape.material.color.setHSL(hue,0.9,0.7);} } else if (currentMovement==='chaos'&&Math.random()<0.01) { if(shape.material)shape.material.color.copy(getRandomPaletteColor()); } }); renderer.render(scene, camera);
        }

        // --- Start Animation (Unchanged) ---
        function startAnimation() { if (animationId) cancelAnimationFrame(animationId); animate(); }

        // --- Movement Patterns (Unchanged) ---
        function applyMovementPattern(time, delta) { /* ... same as before ... */
            const speed=0.5, scaleSpeed=0.3, rotationSpeed=0.4; shapes.forEach((shape, index)=>{ const offsetTime=time+index*0.1; switch(currentMovement){ case 'vortex': shape.position.x=Math.sin(offsetTime*speed)*(25+index*0.1); shape.position.y=Math.cos(offsetTime*speed)*(25+index*0.1); shape.position.z=Math.sin(offsetTime*speed*0.5)*35-35; shape.rotation.x+=delta*rotationSpeed; shape.rotation.y+=delta*rotationSpeed*1.2; break; case 'grid': const gs=Math.ceil(Math.sqrt(currentShapeCount)), sp=12; const gx=(index%gs-gs/2+0.5)*sp; const gy=(Math.floor(index/gs)-gs/2+0.5)*sp; shape.position.set(gx,gy,Math.sin(offsetTime*0.5)*18); const scale=1+Math.sin(offsetTime*scaleSpeed*2)*0.5; shape.scale.set(scale,scale,scale); shape.rotation.z+=delta*rotationSpeed*0.5; break; case 'chaos': shape.position.x+=(Math.random()-0.5)*delta*25; shape.position.y+=(Math.random()-0.5)*delta*25; shape.position.z+=(Math.random()-0.5)*delta*25; shape.position.clampScalar(-70,70); shape.rotation.x+=delta*rotationSpeed*(Math.random()-0.5)*2; shape.rotation.y+=delta*rotationSpeed*(Math.random()-0.5)*2; shape.scale.setScalar(1+Math.sin(offsetTime*scaleSpeed)*0.3); break; case 'tunnel': shape.position.z+=delta*35*(1+index*0.01); shape.rotation.z+=delta*rotationSpeed*2; shape.rotation.x+=delta*rotationSpeed*0.5; const radius=18+Math.sin(offsetTime*0.2)*6; const angle=offsetTime*0.3+index*Math.PI*0.1; shape.position.x=Math.cos(angle)*radius; shape.position.y=Math.sin(angle)*radius; if(shape.position.z>camera.position.z){ shape.position.z=-180-Math.random()*60; if(!usePaletteGradient&&shape.material)shape.material.color.copy(getRandomPaletteColor(index/shapes.length)); } break; case 'wave': const ws=0.8, wa=18, wf=0.1; shape.position.x=(index%15-7.5)*6; shape.position.y=Math.sin(shape.position.x*wf+time*ws)*wa; shape.position.z=Math.cos(time*ws*0.7+index*0.1)*25-10; shape.rotation.y+=delta*rotationSpeed; shape.scale.setScalar(1+Math.cos(time*ws+index*0.2)*0.4); break; } });
        }

        // --- Event Handlers ---
        function onWindowResize() { /* ... same as before ... */
            if(!renderer||!camera||!canvasContainer)return; const w=canvasContainer.clientWidth; const h=canvasContainer.clientHeight; if(w===0||h===0)return; camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h);
        }
        colorPaletteSelect.addEventListener('change', updatePalette);
        usePaletteGradientCheckbox.addEventListener('change', updatePalette);
        customColorInputs.forEach(input => input.addEventListener('input', () => { if (colorPaletteSelect.value === 'custom') updatePalette(); }));
        movementPatternSelect.addEventListener('change', (e) => { currentMovement = e.target.value; updatePalette(); });
        shapeTypeSelect.addEventListener('change', (e) => { currentShapeType = e.target.value; textOptionsDiv.classList.toggle('hidden', !(currentShapeType === 'text' || currentShapeType === 'mixed_all')); createShapes(); });
        textInput.addEventListener('change', (e) => { currentText = e.target.value; if (currentShapeType === 'text' || currentShapeType === 'mixed_all') { createShapes(); } });
        shapeCountSlider.addEventListener('input', (e) => { currentShapeCount = parseInt(e.target.value, 10); shapeCountLabel.textContent = `${currentShapeCount} objects`; });
        shapeCountSlider.addEventListener('change', createShapes);
        backgroundTypeSelect.addEventListener('change', updateBackground);
        backgroundColorSolidInput.addEventListener('input', updateBackground);
        backgroundColorGradient1Input.addEventListener('input', updateBackground);
        backgroundColorGradient2Input.addEventListener('input', updateBackground);
        gradientDirectionSelect.addEventListener('change', updateBackground);

        // --- MP4 Support Check (Unchanged) ---
        function checkMp4Support() { /* ... same as before ... */
             const m='video/mp4'; const o=document.getElementById('mp4-option'); if(MediaRecorder?.isTypeSupported?.(m)){o.disabled=false;}else{o.disabled=true; if(videoFormatSelect.value===m){videoFormatSelect.value='video/webm; codecs=vp9';} showMessage('Note: MP4 recording may not be supported. WebM recommended.');}
        }

        // --- Recording Logic (Unchanged) ---
        function startRecording() { /* ... same as before ... */
            if(!window.MediaRecorder){showMessage('Error: MediaRecorder API not supported.', true); return;} const c=renderer?.domElement; if(!c||c.width===0||c.height===0){showMessage('Error: Canvas not ready.', true); return;} const sf=videoFormatSelect.value; const op={mimeType:sf}; const fe=sf.includes('mp4')?'mp4':'webm'; if(!MediaRecorder.isTypeSupported(sf)){const fb='video/webm; codecs=vp8'; showMessage(`Warning: ${sf} not supported. Trying ${fb}.`, true); op.mimeType=fb; if(!MediaRecorder.isTypeSupported(op.mimeType)){showMessage(`Error: ${op.mimeType} not supported. Cannot record.`, true); return;}} try{mediaRecorder=new MediaRecorder(c.captureStream(30),op);}catch(e){showMessage(`Error creating MediaRecorder: ${e.message}. Try WebM.`, true); console.error(e); return;} recordedChunks=[]; mediaRecorder.ondataavailable=(e)=>{if(e.data.size>0)recordedChunks.push(e.data);}; mediaRecorder.onstop=()=>{const b=new Blob(recordedChunks,{type:op.mimeType}); const u=URL.createObjectURL(b); downloadLink.href=u; const n=new Date(); const ts=`${n.getFullYear()}${String(n.getMonth()+1).padStart(2,'0')}${String(n.getDate()).padStart(2,'0')}_${String(n.getHours()).padStart(2,'0')}${String(n.getMinutes()).padStart(2,'0')}`; downloadLink.download=`futuristic_animation_${currentMovement}_${currentShapeType}_${ts}.${fe}`; downloadLink.classList.remove('hidden'); downloadLink.classList.add('inline-flex'); startRecordBtn.disabled=false; stopRecordBtn.disabled=true; startRecordBtn.classList.remove('btn-disabled'); stopRecordBtn.classList.add('btn-disabled'); videoFormatSelect.disabled=false; recordingIndicator.style.display='none'; showMessage('Recording stopped. Click Download Video.');}; mediaRecorder.onerror=(e)=>{showMessage(`Recording error: ${e.error.message}. Try WebM.`, true); console.error(e.error); stopRecording();}; mediaRecorder.start(); startRecordBtn.disabled=true; stopRecordBtn.disabled=false; startRecordBtn.classList.add('btn-disabled'); stopRecordBtn.classList.remove('btn-disabled'); videoFormatSelect.disabled=true; downloadLink.classList.add('hidden'); recordingIndicator.style.display='block'; showMessage(`Recording started (${op.mimeType})...`);
        }
        function stopRecording() { /* ... same as before ... */
            if(mediaRecorder?.state!=='inactive'){mediaRecorder.stop(); mediaRecorder.stream.getTracks().forEach(t=>t.stop());} startRecordBtn.disabled=false; stopRecordBtn.disabled=true; startRecordBtn.classList.remove('btn-disabled'); stopRecordBtn.classList.add('btn-disabled'); videoFormatSelect.disabled=false; recordingIndicator.style.display='none';
        }

         // --- Utility Functions ---
         function showMessage(message, isError = false) { /* ... same as before ... */
             messageBox.textContent=message; messageBox.style.backgroundColor=isError?'rgba(220,38,38,0.8)':'rgba(0,0,0,0.8)'; messageBox.style.display='block'; setTimeout(()=>{messageBox.style.display='none';}, isError?6000:4000);
         }

        // --- Run ---
         window.onload = () => {
             loadAssets(); // Start loading assets
             // initThreeJS() is called when assets are loaded/processed
         };

    </script>
</body>
</html>

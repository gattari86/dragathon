    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('artCanvas');
        const ctx = canvas.getContext('2d');
        // Buttons
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const regenerateBtn = document.getElementById('regenerateBtn');
        const downloadPngBtn = document.getElementById('downloadPngBtn');
        const downloadWebmBtn = document.getElementById('downloadWebmBtn');
        const startRecordBtn = document.getElementById('startRecordBtn');
        const stopRecordBtn = document.getElementById('stopRecordBtn');
        // Sliders & Value Displays
        const intensitySlider = document.getElementById('intensity');
        const intensityValue = document.getElementById('intensityValue');
        const blurSlider = document.getElementById('blur');
        const blurValue = document.getElementById('blurValue');
        const minRadiusSlider = document.getElementById('minRadius');
        const minRadiusValue = document.getElementById('minRadiusValue');
        const maxRadiusSlider = document.getElementById('maxRadius');
        const maxRadiusValue = document.getElementById('maxRadiusValue');
        const opacitySlider = document.getElementById('opacity');
        const opacityValue = document.getElementById('opacityValue');
        const speedSlider = document.getElementById('speed');
        const speedValue = document.getElementById('speedValue');
        // Circle Color Inputs
        const circleColorInputs = Array.from(document.querySelectorAll('.circle-color'));
        // Background Controls
        const backgroundTypeRadios = Array.from(document.querySelectorAll('input[name="backgroundType"]'));
        const solidColorOptionDiv = document.getElementById('solidColorOption');
        const gradientOptionsDiv = document.getElementById('gradientOptions');
        const bgColor1Input = document.getElementById('bgColor1'); // Input for SOLID color
        const bgColorGradient1Input = document.getElementById('bgColorGradient1'); // Input for GRADIENT color 1
        const bgColorGradient2Input = document.getElementById('bgColorGradient2'); // Input for GRADIENT color 2
        // Status/Indicators
        const statusMessage = document.getElementById('statusMessage');
        const recordingIndicator = document.getElementById('recordingIndicator');

        // --- State Variables ---
        let baseCircleColors = [];
        let intensity = 50;
        let blurAmount = 15;
        let minRadiusPercent = 5;
        let maxRadiusPercent = 25;
        let maxOpacity = 0.7;
        let speedMultiplier = 1.0;
        let circles = [];
        let animationFrameId = null;
        let isPaused = false;
        let canvasWidth = 0;
        let canvasHeight = 0;
        let statusTimeout = null;
        // Background state
        let backgroundType = 'solid'; // 'solid', 'linear', 'radial'
        let backgroundColor1 = '#FFFFFF'; // Holds the first color (either solid OR gradient start)
        let backgroundColor2 = '#CCCCCC'; // Holds the second color (gradient end)

        // --- Media Recorder State ---
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        const MimeType = 'video/webm;codecs=vp9';

        // --- Helper Functions ---
        function getRandomFloat(min, max) { return Math.random() * (max - min) + min; }
        function getRandomCircleColor() { return baseCircleColors.length > 0 ? baseCircleColors[Math.floor(Math.random() * baseCircleColors.length)] : '#000000'; }
        function hexToRgba(hex, alpha) {
            let r=0, g=0, b=0;
            // Allow shorthand hex (#RGB)
            if(hex.length == 4){ r = parseInt(hex[1]+hex[1], 16); g = parseInt(hex[2]+hex[2], 16); b = parseInt(hex[3]+hex[3], 16); }
            // Standard hex (#RRGGBB)
            else if(hex.length == 7){ r = parseInt(hex[1]+hex[2], 16); g = parseInt(hex[3]+hex[4], 16); b = parseInt(hex[5]+hex[6], 16); }
            return `rgba(${r},${g},${b},${alpha})`;
        }
        function showStatus(message, duration = 3000) {
             clearTimeout(statusTimeout);
             statusMessage.textContent = message;
             if (duration > 0) {
                 statusTimeout = setTimeout(() => statusMessage.textContent = '', duration);
             }
        }

        // --- Update State from UI ---
        function updateStateFromUI() {
            // Circle properties
            baseCircleColors = circleColorInputs.map(input => input.value);
            intensity = parseInt(intensitySlider.value, 10);
            blurAmount = parseInt(blurSlider.value, 10); // Read blur value
            minRadiusPercent = parseInt(minRadiusSlider.value, 10);
            maxRadiusPercent = parseInt(maxRadiusSlider.value, 10);
            maxOpacity = parseFloat(opacitySlider.value);
            speedMultiplier = parseFloat(speedSlider.value);

            // Background properties
            const selectedRadio = backgroundTypeRadios.find(radio => radio.checked);
            backgroundType = selectedRadio ? selectedRadio.value : 'solid';

            // *** FIX START: Read correct background colors based on type ***
            if (backgroundType === 'solid') {
                backgroundColor1 = bgColor1Input.value;
                // backgroundColor2 is not used for solid
            } else {
                // For gradients, read from the gradient color inputs
                backgroundColor1 = bgColorGradient1Input.value; // Use the FIRST gradient input
                backgroundColor2 = bgColorGradient2Input.value; // Use the SECOND gradient input
            }
             // *** FIX END ***

            // Update display values
            intensityValue.textContent = intensity;
            blurValue.textContent = blurAmount;
            minRadiusValue.textContent = minRadiusPercent;
            maxRadiusValue.textContent = maxRadiusPercent;
            opacityValue.textContent = maxOpacity.toFixed(2);
            speedValue.textContent = speedMultiplier.toFixed(1);

             // Ensure min radius slider doesn't exceed max radius slider visually
             if (minRadiusPercent > maxRadiusPercent) {
                 minRadiusSlider.value = maxRadiusPercent;
                 minRadiusPercent = maxRadiusPercent;
                 minRadiusValue.textContent = minRadiusPercent;
             }

            // Toggle visibility of background color pickers
            solidColorOptionDiv.classList.toggle('hidden', backgroundType !== 'solid');
            gradientOptionsDiv.classList.toggle('hidden', backgroundType === 'solid');
        }

        // --- Canvas and Circle Initialization ---
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvasWidth = container.clientWidth;
            canvasHeight = container.clientHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }

        function initializeCircles() {
            circles = [];
            const baseDimension = Math.min(canvasWidth, canvasHeight);
            const minRadiusPx = (minRadiusPercent / 100) * baseDimension;
            const maxRadiusPx = (maxRadiusPercent / 100) * baseDimension;
            const baseSpeed = baseDimension * 0.001;

            const finalMinRadiusPx = Math.min(minRadiusPx, maxRadiusPx);
            const finalMaxRadiusPx = Math.max(minRadiusPx, maxRadiusPx);

            for (let i = 0; i < intensity; i++) {
                const radius = getRandomFloat(finalMinRadiusPx, finalMaxRadiusPx);
                const angle = getRandomFloat(0, Math.PI * 2);
                const currentSpeed = baseSpeed * speedMultiplier;

                circles.push({
                    x: getRandomFloat(radius, canvasWidth - radius),
                    y: getRandomFloat(radius, canvasHeight - radius),
                    radius: radius,
                    color: getRandomCircleColor(),
                    vx: Math.cos(angle) * currentSpeed,
                    vy: Math.sin(angle) * currentSpeed,
                    opacity: getRandomFloat(0.1, maxOpacity)
                });
            }
             showStatus("");
        }

        // --- Drawing Functions ---
        function drawBackground() {
            ctx.filter = 'none'; // Ensure no filter

            if (backgroundType === 'solid') {
                ctx.fillStyle = backgroundColor1;
            } else if (backgroundType === 'linear') {
                const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
                gradient.addColorStop(0, backgroundColor1); // Uses corrected color 1
                gradient.addColorStop(1, backgroundColor2);
                ctx.fillStyle = gradient;
            } else if (backgroundType === 'radial') {
                const centerX = canvasWidth / 2;
                const centerY = canvasHeight / 2;
                const outerRadius = Math.sqrt(centerX*centerX + centerY*centerY);
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, outerRadius);
                gradient.addColorStop(0, backgroundColor1); // Uses corrected color 1
                gradient.addColorStop(1, backgroundColor2);
                ctx.fillStyle = gradient;
            }
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        function drawCircles() {
             // console.log("Applying blur:", blurAmount); // <-- Temporary DEBUG line
             ctx.filter = `blur(${blurAmount}px)`; // Use the state variable directly

             circles.forEach(circle => {
                 ctx.beginPath();
                 ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                 ctx.fillStyle = hexToRgba(circle.color, circle.opacity);
                 ctx.fill();
             });

             ctx.filter = 'none'; // Reset filter
        }


        // --- Animation Loop ---
        function updateCirclePositions() {
            // Speed adjustment is now handled primarily in the slider event listener
            circles.forEach(circle => {
                circle.x += circle.vx;
                circle.y += circle.vy;

                // Boundary collision
                if (circle.x - circle.radius < 0 || circle.x + circle.radius > canvasWidth) {
                    circle.vx *= -1;
                    circle.x = Math.max(circle.radius, Math.min(canvasWidth - circle.radius, circle.x));
                }
                if (circle.y - circle.radius < 0 || circle.y + circle.radius > canvasHeight) {
                    circle.vy *= -1;
                    circle.y = Math.max(circle.radius, Math.min(canvasHeight - circle.radius, circle.y));
                }
            });
        }

        function drawFrame() {
             drawBackground(); // Draw background first
             drawCircles();    // Draw blurred circles on top
        }

        function animate() {
            if (isPaused) return;
            updateCirclePositions();
            drawFrame(); // Will use the latest state variables (incl. blurAmount)
            animationFrameId = requestAnimationFrame(animate);
        }

        // --- Control Functions ---
        function playAnimation() {
            if (animationFrameId === null || isPaused) {
                 isPaused = false;
                 playBtn.disabled = true;
                 pauseBtn.disabled = false;
                 startRecordBtn.disabled = isRecording;
                 downloadWebmBtn.disabled = false;
                 showStatus("");
                 animate();
            }
        }

        function pauseAnimation() {
             if (animationFrameId !== null && !isPaused) {
                 isPaused = true;
                 cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
                 playBtn.disabled = false;
                 pauseBtn.disabled = true;
                 startRecordBtn.disabled = true;
                 stopRecordBtn.disabled = !isRecording;
                 downloadWebmBtn.disabled = true;
                 showStatus("Paused");
            }
        }

        function regenerateArt() {
            const wasPaused = isPaused;
            pauseAnimation();
            updateStateFromUI(); // Read latest settings *** BEFORE initializing ***
            // resizeCanvas(); // Resize only happens on window resize event
            initializeCircles(); // Create circles based on new state
            drawFrame(); // Draw initial frame

            // Reset controls
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            startRecordBtn.disabled = true;
            stopRecordBtn.disabled = true;
            downloadWebmBtn.disabled = true;
            isPaused = true;

            if (isRecording) {
                stopRecording(); // Safety stop if somehow recording
                showStatus("Recording stopped. New art generated.");
            } else {
                showStatus("New art generated. Press Play.");
            }
        }

        // --- Media Recorder Functions ---
        // (No changes needed in Media Recorder functions)
        function handleDataAvailable(event) { if (event.data && event.data.size > 0) { recordedChunks.push(event.data); } }
        function handleStopRecording() {
            isRecording = false;
            recordingIndicator.classList.add('hidden');
            showStatus('Processing video...', 0);
            const blob = new Blob(recordedChunks, { type: MimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `blur-art-animation.webm`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            recordedChunks = [];
            mediaRecorder = null;
            startRecordBtn.disabled = isPaused;
            stopRecordBtn.disabled = true;
            regenerateBtn.disabled = false;
            downloadPngBtn.disabled = false;
            downloadWebmBtn.disabled = isPaused;
            playBtn.disabled = isPaused;
            pauseBtn.disabled = !isPaused;
            showStatus('WEBM Video ready!');
        }
        function startRecording() {
            if (!window.MediaRecorder || !MediaRecorder.isTypeSupported(MimeType)) { showStatus(`Error: Recording (${MimeType}) not supported.`); console.error('MediaRecorder API or MimeType not supported.'); return; }
            if (isRecording || isPaused) return;
            isRecording = true;
            recordedChunks = [];
            recordingIndicator.classList.remove('hidden');
            showStatus('Recording...', 0);
            startRecordBtn.disabled = true;
            stopRecordBtn.disabled = false;
            regenerateBtn.disabled = true;
            downloadPngBtn.disabled = true;
            downloadWebmBtn.disabled = true;
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            try {
                 const stream = canvas.captureStream(30);
                 mediaRecorder = new MediaRecorder(stream, { mimeType: MimeType });
                 mediaRecorder.ondataavailable = handleDataAvailable;
                 mediaRecorder.onstop = handleStopRecording;
                 mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event.error);
                    showStatus(`Recording Error: ${event.error.name}`);
                    isRecording = false; recordingIndicator.classList.add('hidden'); startRecordBtn.disabled = isPaused; stopRecordBtn.disabled = true; regenerateBtn.disabled = false; downloadPngBtn.disabled = false; downloadWebmBtn.disabled = isPaused; playBtn.disabled = isPaused; pauseBtn.disabled = !isPaused;
                 };
                 mediaRecorder.start();
            } catch (error) {
                 console.error("Error starting MediaRecorder:", error);
                 showStatus(`Error: ${error.message}`);
                 isRecording = false; recordingIndicator.classList.add('hidden'); startRecordBtn.disabled = isPaused; stopRecordBtn.disabled = true; regenerateBtn.disabled = false; downloadPngBtn.disabled = false; downloadWebmBtn.disabled = isPaused; playBtn.disabled = isPaused; pauseBtn.disabled = !isPaused;
            }
        }
        function stopRecording() { if (mediaRecorder && isRecording) { mediaRecorder.stop(); showStatus('Stopping recording...'); } }

        // --- Event Listeners ---
        playBtn.addEventListener('click', playAnimation);
        pauseBtn.addEventListener('click', pauseAnimation);
        regenerateBtn.addEventListener('click', regenerateArt);
        startRecordBtn.addEventListener('click', startRecording);
        stopRecordBtn.addEventListener('click', stopRecording);
        downloadPngBtn.addEventListener('click', () => {
            if (isPaused) drawFrame();
            const link = document.createElement('a');
            link.download = 'blur-art-frame.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            showStatus("PNG frame downloaded");
        });
        downloadWebmBtn.addEventListener('click', () => {
            if (isRecording) { stopRecording(); }
            else { showStatus("Start recording first to download WEBM."); }
        });

        // Combined listener for sliders, colors, and background controls
        const allControls = [
             intensitySlider, blurSlider, minRadiusSlider, maxRadiusSlider, opacitySlider, speedSlider,
             ...circleColorInputs, ...backgroundTypeRadios, bgColor1Input, bgColorGradient1Input, bgColorGradient2Input
        ];

        allControls.forEach(input => {
            input.addEventListener('input', (event) => {
                 const previousSpeed = speedMultiplier;
                 const previousBgType = backgroundType;
                 updateStateFromUI(); // Update state variables based on the control that fired the event

                 const changedInput = event.target;

                 // Define controls that require full regeneration
                 const requiresRegen = [
                     intensitySlider, minRadiusSlider, maxRadiusSlider, opacitySlider,
                     bgColor1Input, // Solid BG Color
                     bgColorGradient1Input, // Gradient BG Color 1
                     bgColorGradient2Input, // Gradient BG Color 2
                     ...circleColorInputs
                 ].includes(changedInput);

                 // Check if background *type* changed
                 const backgroundTypeChanged = backgroundTypeRadios.includes(changedInput) && backgroundType !== previousBgType;

                 if (requiresRegen || backgroundTypeChanged) {
                     // Regenerate immediately for changes affecting setup or background appearance
                     regenerateArt(); // Handles pause, re-init, redraw, keeps paused
                     // Status message handled within regenerateArt
                 } else if (changedInput === speedSlider) {
                     // Speed slider: Update circle velocities live
                     const baseDimension = Math.min(canvasWidth, canvasHeight);
                     const baseSpeed = baseDimension * 0.001;
                     circles.forEach(circle => {
                         const currentMagnitude = Math.sqrt(circle.vx * circle.vx + circle.vy * circle.vy);
                         const targetSpeed = baseSpeed * speedMultiplier;
                         if (currentMagnitude > 0.0001) {
                             const scaleFactor = targetSpeed / currentMagnitude;
                             circle.vx *= scaleFactor;
                             circle.vy *= scaleFactor;
                         } else {
                             const angle = getRandomFloat(0, Math.PI * 2);
                             circle.vx = Math.cos(angle) * targetSpeed;
                             circle.vy = Math.sin(angle) * targetSpeed;
                         }
                     });
                     showStatus("");
                 } else if (changedInput === blurSlider) {
                     // Blur slider: Applied live in drawFrame. If paused, redraw now.
                     if (isPaused) {
                         drawFrame(); // Redraw immediately with the new blur value
                     }
                      // No status message needed, change is visual
                 }
            });
        });

        // Debounced resize handler
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const wasPaused = isPaused;
                const wasRecording = isRecording;
                if (wasRecording) { stopRecording(); showStatus("Resized - Recording stopped.", 5000); }
                else { showStatus("Resizing...", 1000); }

                pauseAnimation();
                updateStateFromUI(); // Get current control values first
                resizeCanvas();      // THEN resize canvas
                initializeCircles(); // THEN reinitialize circles for new size/state
                drawFrame();         // Draw initial frame

                isPaused = true; // Always start paused after resize
                playBtn.disabled = false; pauseBtn.disabled = true; startRecordBtn.disabled = true; stopRecordBtn.disabled = true; downloadWebmBtn.disabled = true;
                if (!wasRecording) { showStatus("Resized. Press Play."); }
            }, 250);
        });


        // --- Initial Setup ---
        window.onload = () => {
             updateStateFromUI();
             resizeCanvas();
             initializeCircles();
             drawFrame();

             isPaused = true;
             playBtn.disabled = false; pauseBtn.disabled = true; startRecordBtn.disabled = true; stopRecordBtn.disabled = true; downloadWebmBtn.disabled = true;
             showStatus("Ready. Press Play.");
        };

    </script>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Futuristic Metallic Animation Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <style>
      @font-face {
        font-family: 'LucideIcons';
        src: url(https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.ttf) format('truetype');
      }
      .lucide {
        font-family: 'LucideIcons';
        font-size: 1.25rem; /* Adjust size as needed */
        line-height: 1;
        vertical-align: middle;
      }
      #canvas-container {
        width: 100%;
        height: 60vh;
        max-height: 500px;
        position: relative;
        overflow: hidden;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      }
      canvas { display: block; width: 100%; height: 100%; }
      #recording-indicator {
        position: absolute; top: 1rem; right: 1rem; width: 1rem; height: 1rem;
        background-color: red; border-radius: 50%; display: none;
        animation: pulse 1.5s infinite; z-index: 10;
      }
      @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
      .btn { @apply inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 transition-colors duration-150 ease-in-out; }
      .btn-primary { @apply text-white bg-indigo-600 hover:bg-indigo-700 focus:ring-indigo-500; }
      .btn-secondary { @apply text-indigo-700 bg-indigo-100 hover:bg-indigo-200 focus:ring-indigo-500; }
      .btn-danger { @apply text-white bg-red-600 hover:bg-red-700 focus:ring-red-500; }
      .btn-disabled { @apply bg-gray-300 text-gray-500 cursor-not-allowed hover:bg-gray-300; }
      #message-box {
        position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.8); color: white; padding: 0.75rem 1.5rem;
        border-radius: 0.5rem; z-index: 1000; display: none; font-family: 'Inter', sans-serif;
        font-size: 0.875rem; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      }
      .hidden { display: none; }
      .input-base { @apply mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm bg-white disabled:bg-gray-100 disabled:cursor-not-allowed; }
      .color-input { @apply p-1 h-10 w-full block bg-white border border-gray-300 rounded-md shadow-sm cursor-pointer focus:outline-none focus:ring-indigo-500 focus:border-indigo-500; }
      #loading-overlay {
          position: absolute; top: 0; left: 0; width: 100%; height: 100%;
          background-color: rgba(0,0,0,0.7); z-index: 20; display: flex;
          justify-content: center; align-items: center; color: white;
          font-size: 1.2rem; border-radius: 0.5rem; text-align: center;
      }
       /* Simple spinner */
      .spinner {
          border: 4px solid rgba(255, 255, 255, 0.3);
          border-radius: 50%;
          border-top: 4px solid #fff;
          width: 40px;
          height: 40px;
          animation: spin 1s linear infinite;
          margin-bottom: 1rem;
      }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 font-['Inter'] text-gray-800 p-4 md:p-8">

    <div class="max-w-5xl mx-auto bg-white p-6 rounded-lg shadow-lg">
        <h1 class="text-2xl md:text-3xl font-bold mb-6 text-center text-indigo-700">Futuristic Metallic Animation Generator</h1>

        <div id="canvas-container" class="mb-6 bg-black">
            <div id="loading-overlay">
                <div class="flex flex-col items-center">
                     <div class="spinner"></div>
                     <span id="loading-text">Loading Assets...</span>
                 </div>
            </div>
            <div id="recording-indicator" title="Recording..."></div>
            </div>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-6">
            <div class="space-y-2">
                <label for="color-palette" class="block text-sm font-medium text-gray-700">Color Palette:</label>
                <select id="color-palette" name="color-palette" class="input-base">
                    <option value="metallic_cool">Metallic Cool</option> <option value="metallic_warm">Metallic Warm</option>
                    <option value="rainbow">Rainbow</option>
                    <option value="vaporwave">Vaporwave</option>
                    <option value="monochrome">Monochrome</option>
                    <option value="custom">Custom</option>
                </select>
                <div id="custom-colors" class="hidden space-y-2 mt-2">
                     <label class="block text-sm font-medium text-gray-700">Custom Colors (2-5):</label>
                     <input type="color" id="custom-color-1" value="#c0c0c0" class="color-input"> <input type="color" id="custom-color-2" value="#44aadd" class="color-input"> <input type="color" id="custom-color-3" value="#ffffff" class="color-input"> <input type="color" id="custom-color-4" value="#888888" class="color-input"> <input type="color" id="custom-color-5" value="#333333" class="color-input"> <div class="flex items-center mt-2">
                         <input id="use-palette-gradient" type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                         <label for="use-palette-gradient" class="ml-2 block text-sm text-gray-900">Use as Gradient</label>
                     </div>
                </div>
            </div>

            <div class="space-y-2">
                <label for="movement-pattern" class="block text-sm font-medium text-gray-700">Movement Pattern:</label>
                <select id="movement-pattern" name="movement-pattern" class="input-base">
                    <option value="vortex">Spinning Vortex</option>
                    <option value="grid">Pulsating Grid</option>
                    <option value="chaos">Morphing Chaos</option>
                    <option value="tunnel">Infinite Tunnel</option>
                    <option value="wave">Geometric Wave</option>
                </select>
            </div>

             <div class="space-y-2">
                <label for="shape-type" class="block text-sm font-medium text-gray-700">Object Type:</label>
                <select id="shape-type" name="shape-type" class="input-base">
                    <option value="cube">Cubes</option>
                    <option value="sphere">Spheres</option>
                    <option value="torus">Torus Knots</option>
                    <option value="icosahedron">Icosahedrons</option>
                    <option value="mixed_geo">Mixed Geometry</option>
                    <option value="text">Text Only</option>
                    <option value="mixed_all">Mixed Geometry & Text</option>
                </select>
                 <div id="text-options" class="space-y-2 mt-2">
                     <label for="text-input" class="block text-sm font-medium text-gray-700">Text to Add:</label>
                     <input type="text" id="text-input" name="text-input" value="Futuristic" class="input-base" placeholder="Enter text here...">
                 </div>
                 <div class="mt-4 space-y-2">
                    <label for="shape-count" class="block text-sm font-medium text-gray-700">Object Count:</label>
                    <input type="range" id="shape-count" name="shape-count" min="5" max="100" value="30" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700"> <span id="shape-count-label" class="text-sm text-gray-500">30 objects</span>
                </div>
            </div>

             <div class="space-y-2">
                 <label for="background-type" class="block text-sm font-medium text-gray-700">Background:</label>
                 <select id="background-type" name="background-type" class="input-base">
                     <option value="default">Default (Dark)</option>
                     <option value="solid">Solid Color</option>
                     <option value="gradient">Linear Gradient</option>
                 </select>
                 <div id="solid-color-option" class="hidden mt-2">
                     <label for="background-color-solid" class="block text-sm font-medium text-gray-700">Background Color:</label>
                     <input type="color" id="background-color-solid" value="#0a0a0a" class="color-input"> </div>
                 <div id="gradient-color-options" class="hidden space-y-2 mt-2">
                     <label class="block text-sm font-medium text-gray-700">Gradient Colors:</label>
                     <input type="color" id="background-color-gradient-1" value="#000020" class="color-input"> <input type="color" id="background-color-gradient-2" value="#404080" class="color-input"> <label for="gradient-direction" class="block text-sm font-medium text-gray-700">Direction:</label>
                     <select id="gradient-direction" name="gradient-direction" class="input-base">
                         <option value="0">Top to Bottom</option>
                         <option value="1">Left to Right</option>
                         <option value="2">Top-Left to Bottom-Right</option>
                         <option value="3">Bottom to Top</option>
                         <option value="4">Bottom-Left to Top-Right</option>
                     </select>
                 </div>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mt-6 pt-6 border-t border-gray-200">
             <div class="flex items-center gap-2 w-full sm:w-auto">
                 <label for="video-format" class="text-sm font-medium text-gray-700 whitespace-nowrap">Format:</label>
                 <select id="video-format" name="video-format" class="input-base py-1.5">
                     <option value="video/webm; codecs=vp9">WebM (VP9)</option>
                     <option value="video/webm; codecs=vp8">WebM (VP8)</option>
                     <option id="mp4-option" value="video/mp4">MP4 (H.264)</option>
                 </select>
             </div>
             <button id="start-record-btn" class="btn btn-primary w-full sm:w-auto">
                 <span class="lucide mr-2">&#9210;</span> Start Recording
             </button>
             <button id="stop-record-btn" class="btn btn-danger w-full sm:w-auto" disabled>
                 <span class="lucide mr-2">&#9724;</span> Stop Recording
             </button>
             <a id="download-link" class="btn btn-secondary w-full sm:w-auto hidden">
                 <span class="lucide mr-2">&#11123;</span> Download Video
             </a>
        </div>
         <div class="mt-6 text-sm text-gray-600 bg-indigo-50 p-4 rounded-md border border-indigo-200">
            <h3 class="font-semibold text-indigo-800 mb-2">How to Use:</h3>
            <ol class="list-decimal list-inside space-y-1">
                <li>Adjust colors, movement, object type (including text), count, and background.</li>
                <li>Enter desired text if using 'Text Only' or 'Mixed Geometry & Text'.</li>
                <li>Select video recording format (MP4 may not be supported by your browser).</li>
                <li>Click "Start Recording", then "Stop Recording".</li>
                <li>Click "Download Video" to save.</li>
                <li>Note: Using text can impact performance. Lower the object count if needed.</li>
            </ol>
        </div>
    </div>

    <div id="message-box"></div>

    <script id="vertexShader" type="shader/vertex">varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }</script>
    <script id="fragmentShader" type="shader/fragment">varying vec2 vUv; uniform vec3 color1; uniform vec3 color2; uniform float direction; void main() { vec2 uv = vUv; float mixValue; if (direction == 0.0) { mixValue = uv.y; } else if (direction == 1.0) { mixValue = uv.x; } else if (direction == 2.0) { mixValue = (uv.x + uv.y) / 2.0; } else if (direction == 3.0) { mixValue = 1.0 - uv.y; } else if (direction == 4.0) { mixValue = (uv.x + (1.0 - uv.y)) / 2.0; } else { mixValue = uv.y; } gl_FragColor = vec4(mix(color1, color2, mixValue), 1.0); }</script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer, shapes = [];
        let backgroundPlane, backgroundMaterial;
        let animationId;
        let mediaRecorder; let recordedChunks = [];
        let currentPalette = []; let usePaletteGradient = false;
        let currentMovement = 'vortex';
        let currentShapeType = 'cube'; // Default, will be updated
        let currentShapeCount = 30; // Reduced default
        let currentText = 'Futuristic';
        let loadedFont = null; // To store the loaded font
        let environmentMap = null; // To store the loaded env map
        let assetsLoaded = false; // Flag for async loading
        const clock = new THREE.Clock();
        const defaultBgColor = 0x0a0a0a; // Darker default

        // --- DOM Elements ---
        const canvasContainer = document.getElementById('canvas-container');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const colorPaletteSelect = document.getElementById('color-palette');
        const customColorsDiv = document.getElementById('custom-colors');
        const customColorInputs = [ /* ... same as before ... */
             document.getElementById('custom-color-1'), document.getElementById('custom-color-2'),
             document.getElementById('custom-color-3'), document.getElementById('custom-color-4'),
             document.getElementById('custom-color-5'),
        ];
        const usePaletteGradientCheckbox = document.getElementById('use-palette-gradient');
        const movementPatternSelect = document.getElementById('movement-pattern');
        const shapeTypeSelect = document.getElementById('shape-type');
        const textOptionsDiv = document.getElementById('text-options');
        const textInput = document.getElementById('text-input');
        const shapeCountSlider = document.getElementById('shape-count');
        const shapeCountLabel = document.getElementById('shape-count-label');
        const backgroundTypeSelect = document.getElementById('background-type');
        const solidColorOptionDiv = document.getElementById('solid-color-option');
        const backgroundColorSolidInput = document.getElementById('background-color-solid');
        const gradientColorOptionsDiv = document.getElementById('gradient-color-options');
        const backgroundColorGradient1Input = document.getElementById('background-color-gradient-1');
        const backgroundColorGradient2Input = document.getElementById('background-color-gradient-2');
        const gradientDirectionSelect = document.getElementById('gradient-direction');
        const videoFormatSelect = document.getElementById('video-format');
        const mp4Option = document.getElementById('mp4-option');
        const startRecordBtn = document.getElementById('start-record-btn');
        const stopRecordBtn = document.getElementById('stop-record-btn');
        const downloadLink = document.getElementById('download-link');
        const recordingIndicator = document.getElementById('recording-indicator');
        const messageBox = document.getElementById('message-box');

        // --- Palettes (Added Metallic) ---
        const palettes = {
            metallic_cool: [0xc0c0c0, 0x808080, 0xadd8e6, 0x4682b4, 0x778899], // Silver, Gray, Light Blue, Steel Blue, Slate Gray
            metallic_warm: [0xb8860b, 0xffd700, 0xcd7f32, 0x8b4513, 0xdda0dd], // Dark Goldenrod, Gold, Bronze, Saddle Brown, Plum (for contrast)
            rainbow: [0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x0000ff, 0x4b0082, 0x9400d3],
            vaporwave: [0xff71ce, 0x01cdfe, 0x05ffa1, 0xb967ff, 0xfff79a],
            monochrome: [0x000000, 0x444444, 0x888888, 0xcccccc, 0xffffff],
            custom: []
        };

        // --- Asset Loading ---
        function loadAssets() {
            const fontLoader = new THREE.FontLoader();
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            const textureLoader = new THREE.TextureLoader(); // For fallback if cube texture fails

            // URLs (Using unpkg CDN)
            const fontURL = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json';
            const envMapBaseURL = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/textures/cube/pisa/';
            const envMapURLs = [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ].map(f => envMapBaseURL + f);

            let fontLoaded = false;
            let envMapLoaded = false;

            function checkAssetsLoaded() {
                if (fontLoaded && envMapLoaded) {
                    assetsLoaded = true;
                    loadingOverlay.style.display = 'none'; // Hide loading overlay
                    console.log("Assets loaded successfully.");
                    // Initialize the rest of the application
                    initThreeJS();
                }
            }

            loadingText.textContent = "Loading Font...";
            fontLoader.load(fontURL, (font) => {
                console.log("Font loaded.");
                loadedFont = font;
                fontLoaded = true;
                 loadingText.textContent = "Loading Textures...";
                checkAssetsLoaded();
            }, undefined, (error) => {
                console.error('Font loading failed:', error);
                showMessage('Error: Failed to load font. Text features disabled.', true);
                fontLoaded = true; // Mark as loaded to proceed without text
                 loadingText.textContent = "Loading Textures...";
                checkAssetsLoaded();
            });

             loadingText.textContent = "Loading Environment Map...";
            cubeTextureLoader.load(envMapURLs, (texture) => {
                console.log("Environment map loaded.");
                environmentMap = texture;
                 environmentMap.encoding = THREE.sRGBEncoding; // Ensure correct color space
                envMapLoaded = true;
                checkAssetsLoaded();
            }, undefined, (error) => {
                console.error('CubeTexture loading failed:', error);
                 showMessage('Warning: Failed to load environment map. Metallic effect reduced.', true);
                // Fallback: Maybe load a simple texture or just proceed without env map
                envMapLoaded = true; // Mark as loaded to proceed
                checkAssetsLoaded();
            });
        }


        // --- Initialization ---
        function initThreeJS() { // Renamed from init()
            if (!assetsLoaded) {
                console.error("Assets not loaded, cannot initialize Three.js scene.");
                return;
            }
            // Scene setup
            scene = new THREE.Scene();
            scene.environment = environmentMap; // Apply environment map globally

            // Camera setup
            const aspectRatio = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera.position.z = 50;

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setClearColor(defaultBgColor, 1.0);
             renderer.outputEncoding = THREE.sRGBEncoding; // Match env map encoding
             renderer.toneMapping = THREE.ACESFilmicToneMapping; // Improve realism
             renderer.toneMappingExposure = 1.0;
            canvasContainer.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Slightly lower intensity
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Slightly higher intensity
            directionalLight.position.set(8, 15, 10);
            scene.add(directionalLight);
            // Add another light for more dynamic reflections
            const pointLight = new THREE.PointLight(0xffffff, 0.6, 200);
            pointLight.position.set(-10, -5, 20);
            scene.add(pointLight);

            // Create Gradient Background Plane
            createBackgroundPlane();

            // Initial setup based on UI defaults
            currentShapeType = shapeTypeSelect.value;
            currentText = textInput.value;
            currentShapeCount = parseInt(shapeCountSlider.value, 10);
            updatePalette();
            updateBackground();
            createShapes(); // Create initial shapes/text
            checkMp4Support();
            startAnimation();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- Background Plane Creation (Unchanged) ---
        function createBackgroundPlane() {
             const planeGeometry = new THREE.PlaneGeometry(2, 2);
             const uniforms = { color1: { value: new THREE.Color(0x1e3a8a) }, color2: { value: new THREE.Color(0xf472b6) }, direction: { value: 0.0 } };
             backgroundMaterial = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: document.getElementById('vertexShader').textContent, fragmentShader: document.getElementById('fragmentShader').textContent, depthWrite: false, depthTest: false });
             backgroundPlane = new THREE.Mesh(planeGeometry, backgroundMaterial);
             backgroundPlane.position.z = -500; backgroundPlane.visible = false;
             scene.add(backgroundPlane);
        }

        // --- Shape & Text Creation (UPDATED) ---
        function createShapes() {
            if (!assetsLoaded || !scene) return; // Don't create if assets or scene not ready

            // Clear existing shapes
            shapes.forEach(shape => scene.remove(shape));
            shapes = [];

            const includesText = currentShapeType === 'text' || currentShapeType === 'mixed_all';
            const includesGeometry = currentShapeType !== 'text';

            // Check if font is needed and available
            if (includesText && !loadedFont) {
                showMessage("Font not loaded, cannot create text shapes.", true);
                return; // Or default to geometry only? For now, just stop.
            }

            for (let i = 0; i < currentShapeCount; i++) {
                let geometry;
                let isTextShape = false;

                // Determine type for this iteration
                if (currentShapeType === 'text') {
                    isTextShape = true;
                } else if (currentShapeType === 'mixed_all') {
                    isTextShape = Math.random() < 0.3; // 30% chance of text
                } else {
                    isTextShape = false; // Geometry only types
                }

                // Create Geometry or TextGeometry
                if (isTextShape) {
                    if (!currentText || currentText.trim() === "") continue; // Skip if no text entered
                    geometry = new THREE.TextGeometry(currentText, {
                        font: loadedFont,
                        size: 3, // Adjust size as needed
                        height: 0.5, // Depth of the text
                        curveSegments: 4, // Lower for performance
                        // No bevels for performance
                        bevelEnabled: false
                    });
                    geometry.center(); // Center the text geometry
                } else if (includesGeometry) {
                    // Use existing geometry logic
                    const geoType = (currentShapeType === 'mixed_geo' || currentShapeType === 'mixed_all') ? 'mixed' : currentShapeType;
                    geometry = getGeometry(geoType);
                } else {
                    continue; // Should not happen, but safety check
                }

                if (!geometry) continue; // Skip if geometry creation failed

                // Create Material (Metallic)
                const material = new THREE.MeshStandardMaterial({
                    color: getRandomPaletteColor(i / currentShapeCount),
                    metalness: 0.9, // High metalness
                    roughness: 0.25, // Moderate roughness for visible reflections
                    envMap: environmentMap, // Apply environment map
                    transparent: true, // Keep for potential effects, adjust if needed
                    opacity: 0.9 // Slightly less transparent
                });

                // Create Mesh
                const shape = new THREE.Mesh(geometry, material);

                // Initial positioning and scaling (adjust scale for text)
                 const initialScale = isTextShape ? 1.5 : Math.random() * 2 + 1;
                 shape.scale.setScalar(initialScale);
                shape.position.set((Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100);
                shape.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);

                shapes.push(shape);
                scene.add(shape);
            }
        }

        // --- Geometry Helper (Added 'mixed_geo') ---
        function getGeometry(type) {
            // Handle specific types first
             if (type === 'mixed_geo' || type === 'mixed') { // Treat both as mixed geometry
                const geoTypes = ['cube', 'sphere', 'torus', 'icosahedron'];
                const randomType = geoTypes[Math.floor(Math.random() * geoTypes.length)];
                return getGeometry(randomType); // Recursive call for a random basic shape
             }

             // Cache check
            if (!getGeometry.cache) getGeometry.cache = {};
            if (getGeometry.cache[type]) return getGeometry.cache[type];

            let geometry;
            switch (type) {
                case 'sphere': geometry = new THREE.SphereGeometry(1.2, 32, 16); break; // Slightly larger
                case 'torus': geometry = new THREE.TorusKnotGeometry(1, 0.3, 100, 16); break; // Slightly larger
                case 'icosahedron': geometry = new THREE.IcosahedronGeometry(1.5); break; // Slightly larger
                case 'cube': default: geometry = new THREE.BoxGeometry(1.8, 1.8, 1.8); break; // Slightly larger
            }
            getGeometry.cache[type] = geometry; // Cache the geometry
            return geometry;
        }

        // --- Palette Management (Unchanged) ---
        function updatePalette() { /* ... same as before ... */
            const selectedPalette = colorPaletteSelect.value;
            usePaletteGradient = usePaletteGradientCheckbox.checked && selectedPalette === 'custom';
            if (selectedPalette === 'custom') {
                customColorsDiv.classList.remove('hidden');
                currentPalette = customColorInputs.map(input => new THREE.Color(input.value)).filter(Boolean);
                if (currentPalette.length < 2) {
                    showMessage("Custom palette needs at least 2 valid colors.", true);
                    currentPalette = palettes.metallic_cool.map(hex => new THREE.Color(hex)); // Default metallic
                    usePaletteGradient = false;
                }
            } else {
                customColorsDiv.classList.add('hidden');
                currentPalette = palettes[selectedPalette].map(hex => new THREE.Color(hex));
                usePaletteGradient = false;
            }
            shapes.forEach((shape, index) => { // Update existing shapes
                if (shape.material) shape.material.color.copy(getRandomPaletteColor(index / shapes.length));
            });
        }

        // --- Get Random Palette Color (Unchanged) ---
        function getRandomPaletteColor(t = Math.random()) { /* ... same as before ... */
             if (currentPalette.length === 0) return new THREE.Color(0xc0c0c0); // Default silver
             if (usePaletteGradient && currentPalette.length >= 2) {
                 const segment = 1 / (currentPalette.length - 1);
                 const index = Math.min(Math.floor(t / segment), currentPalette.length - 2);
                 const localT = (t % segment) / segment;
                 return new THREE.Color().lerpColors(currentPalette[index], currentPalette[index + 1], localT);
             } else {
                 return currentPalette[Math.floor(Math.random() * currentPalette.length)];
             }
        }

        // --- Background Management (Unchanged) ---
        function updateBackground() { /* ... same as before ... */
            const type = backgroundTypeSelect.value;
            solidColorOptionDiv.classList.toggle('hidden', type !== 'solid');
            gradientColorOptionsDiv.classList.toggle('hidden', type !== 'gradient');
            if (type === 'gradient') {
                const gradColor1 = backgroundColorGradient1Input.value;
                const gradColor2 = backgroundColorGradient2Input.value;
                const gradDirection = parseFloat(gradientDirectionSelect.value);
                if (backgroundMaterial?.uniforms) {
                    backgroundMaterial.uniforms.color1.value.set(gradColor1);
                    backgroundMaterial.uniforms.color2.value.set(gradColor2);
                    backgroundMaterial.uniforms.direction.value = gradDirection;
                }
                if(backgroundPlane) backgroundPlane.visible = true;
                if(scene) scene.background = null;
                if(renderer) renderer.setClearColor(0x000000, 0);
            } else {
                 if(backgroundPlane) backgroundPlane.visible = false;
                const bgColor = (type === 'solid') ? backgroundColorSolidInput.value : defaultBgColor;
                const colorObj = new THREE.Color(bgColor);
                 if(scene) scene.background = colorObj;
                 if(renderer) renderer.setClearColor(colorObj, 1.0);
            }
        }

        // --- Animation Loop (Unchanged) ---
        function animate() { /* ... same as before ... */
            if (!renderer || !scene || !camera) return; // Guard against missing elements
            animationId = requestAnimationFrame(animate);
            const delta = clock.getDelta(); const time = clock.getElapsedTime();
            applyMovementPattern(time, delta);
            shapes.forEach((shape, index) => { /* ... color update logic ... */
                 if (usePaletteGradient) {
                     const gradientT = (Math.sin(time * 0.5 + index * 0.1) + 1) / 2;
                     shape.material.color.copy(getRandomPaletteColor(gradientT));
                 } else if (currentMovement === 'vortex' || currentMovement === 'grid' || currentMovement === 'wave') {
                      let hue;
                      if (currentMovement === 'vortex') hue = (time * 0.1 + index * 0.01) % 1;
                      if (currentMovement === 'grid') hue = (Math.sin((time + index * 0.1) * 0.3 * 2) + 1) / 2;
                      if (currentMovement === 'wave') { const ws=0.8, wa=15; hue = (shape.position.y / wa * 0.5 + 0.5 + time * 0.05) % 1; }
                      if (hue !== undefined && shape.material && typeof shape.material.color.setHSL === 'function') {
                           // Ensure material exists and has setHSL
                           shape.material.color.setHSL(hue, 0.9, 0.7); // Slightly desaturate/lighten for metallic HSL
                      }
                 } else if (currentMovement === 'chaos' && Math.random() < 0.01) {
                      if (shape.material) shape.material.color.copy(getRandomPaletteColor());
                 }
            });
            renderer.render(scene, camera);
        }

        // --- Start Animation (Unchanged) ---
        function startAnimation() { if (animationId) cancelAnimationFrame(animationId); animate(); }

        // --- Movement Patterns (Unchanged) ---
        function applyMovementPattern(time, delta) { /* ... same as before ... */
             const speed = 0.5, scaleSpeed = 0.3, rotationSpeed = 0.4;
             shapes.forEach((shape, index) => {
                 const offsetTime = time + index * 0.1;
                 switch (currentMovement) { /* ... cases ... */
                     case 'vortex': shape.position.x = Math.sin(offsetTime*speed)*(25+index*0.1); shape.position.y = Math.cos(offsetTime*speed)*(25+index*0.1); shape.position.z = Math.sin(offsetTime*speed*0.5)*35-35; shape.rotation.x += delta*rotationSpeed; shape.rotation.y += delta*rotationSpeed*1.2; break;
                     case 'grid': const gs=Math.ceil(Math.sqrt(currentShapeCount)), sp=12; const gx=(index%gs-gs/2+0.5)*sp; const gy=(Math.floor(index/gs)-gs/2+0.5)*sp; shape.position.set(gx,gy,Math.sin(offsetTime*0.5)*18); const scale=1+Math.sin(offsetTime*scaleSpeed*2)*0.5; shape.scale.set(scale,scale,scale); shape.rotation.z += delta*rotationSpeed*0.5; break;
                     case 'chaos': shape.position.x += (Math.random()-0.5)*delta*25; shape.position.y += (Math.random()-0.5)*delta*25; shape.position.z += (Math.random()-0.5)*delta*25; shape.position.clampScalar(-70,70); shape.rotation.x += delta*rotationSpeed*(Math.random()-0.5)*2; shape.rotation.y += delta*rotationSpeed*(Math.random()-0.5)*2; shape.scale.setScalar(1+Math.sin(offsetTime*scaleSpeed)*0.3); break;
                     case 'tunnel': shape.position.z += delta*35*(1+index*0.01); shape.rotation.z += delta*rotationSpeed*2; shape.rotation.x += delta*rotationSpeed*0.5; const radius=18+Math.sin(offsetTime*0.2)*6; const angle=offsetTime*0.3+index*Math.PI*0.1; shape.position.x=Math.cos(angle)*radius; shape.position.y=Math.sin(angle)*radius; if(shape.position.z>camera.position.z){ shape.position.z=-180-Math.random()*60; if(!usePaletteGradient && shape.material) shape.material.color.copy(getRandomPaletteColor(index/shapes.length)); } break;
                     case 'wave': const ws=0.8, wa=18, wf=0.1; shape.position.x=(index%15-7.5)*6; shape.position.y=Math.sin(shape.position.x*wf+time*ws)*wa; shape.position.z=Math.cos(time*ws*0.7+index*0.1)*25-10; shape.rotation.y += delta*rotationSpeed; shape.scale.setScalar(1+Math.cos(time*ws+index*0.2)*0.4); break;
                 }
             });
        }

        // --- Event Handlers (UPDATED for new controls) ---
        function onWindowResize() { /* ... same as before ... */
             if (!renderer || !camera || !canvasContainer) return;
             const width = canvasContainer.clientWidth; const height = canvasContainer.clientHeight;
             if (width === 0 || height === 0) return;
             camera.aspect = width / height; camera.updateProjectionMatrix();
             renderer.setSize(width, height);
        }
        colorPaletteSelect.addEventListener('change', updatePalette);
        usePaletteGradientCheckbox.addEventListener('change', updatePalette);
        customColorInputs.forEach(input => input.addEventListener('input', () => { if (colorPaletteSelect.value === 'custom') updatePalette(); }));
        movementPatternSelect.addEventListener('change', (e) => { currentMovement = e.target.value; updatePalette(); }); // Re-apply colors on pattern change

        shapeTypeSelect.addEventListener('change', (e) => {
            currentShapeType = e.target.value;
            // Show/hide text input based on selection
            textOptionsDiv.classList.toggle('hidden', !(currentShapeType === 'text' || currentShapeType === 'mixed_all'));
            createShapes(); // Recreate shapes with the new type
        });
         // Trigger recreation when text input changes
         textInput.addEventListener('change', (e) => { // Use 'change' instead of 'input' for less frequent updates
             currentText = e.target.value;
              if (currentShapeType === 'text' || currentShapeType === 'mixed_all') {
                 createShapes();
             }
         });

        shapeCountSlider.addEventListener('input', (e) => { currentShapeCount = parseInt(e.target.value, 10); shapeCountLabel.textContent = `${currentShapeCount} objects`; });
        shapeCountSlider.addEventListener('change', createShapes); // Recreate shapes on release
        backgroundTypeSelect.addEventListener('change', updateBackground);
        backgroundColorSolidInput.addEventListener('input', updateBackground);
        backgroundColorGradient1Input.addEventListener('input', updateBackground);
        backgroundColorGradient2Input.addEventListener('input', updateBackground);
        gradientDirectionSelect.addEventListener('change', updateBackground);

        // --- MP4 Support Check (Unchanged) ---
        function checkMp4Support() { /* ... same as before ... */
             const mp4MimeType = 'video/mp4'; const mp4OptionElement = document.getElementById('mp4-option');
             if (MediaRecorder?.isTypeSupported?.(mp4MimeType)) { mp4OptionElement.disabled = false; } else { mp4OptionElement.disabled = true; if(videoFormatSelect.value === mp4MimeType) { videoFormatSelect.value = 'video/webm; codecs=vp9'; } showMessage('Note: MP4 recording may not be supported. WebM recommended.'); }
        }

        // --- Recording Logic (Unchanged) ---
        function startRecording() { /* ... same as before ... */
            if (!window.MediaRecorder) { showMessage('Error: MediaRecorder API not supported.', true); return; }
            const canvas = renderer?.domElement; if (!canvas || canvas.width === 0 || canvas.height === 0) { showMessage('Error: Canvas not ready.', true); return; }
            const selectedFormat = videoFormatSelect.value; const options = { mimeType: selectedFormat }; const fileExtension = selectedFormat.includes('mp4') ? 'mp4' : 'webm';
            if (!MediaRecorder.isTypeSupported(selectedFormat)) { const fb='video/webm; codecs=vp8'; showMessage(`Warning: ${selectedFormat} not supported. Trying ${fb}.`, true); options.mimeType = fb; if (!MediaRecorder.isTypeSupported(options.mimeType)) { showMessage(`Error: ${options.mimeType} not supported. Cannot record.`, true); return; } }
            try { mediaRecorder = new MediaRecorder(canvas.captureStream(30), options); } catch (e) { showMessage(`Error creating MediaRecorder: ${e.message}. Try WebM.`, true); console.error(e); return; }
            recordedChunks = []; mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => { const blob = new Blob(recordedChunks, { type: options.mimeType }); const url = URL.createObjectURL(blob); downloadLink.href = url; const now = new Date(); const ts = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}`; downloadLink.download = `futuristic_animation_${currentMovement}_${currentShapeType}_${ts}.${fileExtension}`; downloadLink.classList.remove('hidden'); downloadLink.classList.add('inline-flex'); startRecordBtn.disabled = false; stopRecordBtn.disabled = true; startRecordBtn.classList.remove('btn-disabled'); stopRecordBtn.classList.add('btn-disabled'); videoFormatSelect.disabled = false; recordingIndicator.style.display = 'none'; showMessage('Recording stopped. Click Download Video.'); };
            mediaRecorder.onerror = (e) => { showMessage(`Recording error: ${e.error.message}. Try WebM.`, true); console.error(e.error); stopRecording(); };
            mediaRecorder.start(); startRecordBtn.disabled = true; stopRecordBtn.disabled = false; startRecordBtn.classList.add('btn-disabled'); stopRecordBtn.classList.remove('btn-disabled'); videoFormatSelect.disabled = true; downloadLink.classList.add('hidden'); recordingIndicator.style.display = 'block'; showMessage(`Recording started (${options.mimeType})...`);
        }
        function stopRecording() { /* ... same as before ... */
            if (mediaRecorder?.state !== 'inactive') { mediaRecorder.stop(); mediaRecorder.stream.getTracks().forEach(t => t.stop()); }
            startRecordBtn.disabled = false; stopRecordBtn.disabled = true; startRecordBtn.classList.remove('btn-disabled'); stopRecordBtn.classList.add('btn-disabled'); videoFormatSelect.disabled = false; recordingIndicator.style.display = 'none';
        }

         // --- Utility Functions ---
         function showMessage(message, isError = false) { /* ... same as before ... */
             messageBox.textContent = message; messageBox.style.backgroundColor = isError ? 'rgba(220, 38, 38, 0.8)' : 'rgba(0, 0, 0, 0.8)'; messageBox.style.display = 'block'; setTimeout(() => { messageBox.style.display = 'none'; }, isError ? 6000 : 4000);
         }

        // --- Run ---
         window.onload = () => {
             // Start asset loading first
             loadAssets();
             // initThreeJS() will be called by loadAssets when ready
         };

    </script>
</body>
</html>
